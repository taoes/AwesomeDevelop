# MyBatis 执行源码解析

[toc]

前几面的文章中，我们了解MyBatis的基础项目的搭建与配置，本文章中将项目的源码来讲解一下，从源码的角度上来看下MyBatis的启动源码。首先我们来看下基础的项目的代码


```java
  @Test
  public void testResource() throws IOException, SQLException {
    // 1.创建配置文件
    String resource = "mybatis-config.xml";
    InputStream inputStream = Resources.getResourceAsStream(resource);

    // 构建 SQLSessionFactory，以创建 SqlSession
    sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    SqlSession sqlSession = sqlSessionFactory.openSession();

    // 2、执行查询语句
    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);
    List<UserDO> userDOS = mapper.find("A");

    // 关闭Session
    sqlSession.close();
  }
```


### 构建 SqlSessionFactory


通过 `new SqlSessionFactoryBuilder().build(inputStream)` 可以构建一个SQLSessionFactory  ，SQLSessionFactory 可以用来创建 SQLSession ，所以如何通过配置文件 创建一个 SQLSessionFactory是本短重点。


```java
// 通过 build 构建一个 XMLConfigBuilder
public SqlSessionFactory build(inputStream, environment, Properties) {
    try {
      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
      return build(parser.parse());
    } catch (Exception e) {
      throw ExceptionFactory.wrapException("Error building SqlSession.", e);
    } finally {
      ErrorContext.instance().reset();
      try {
        inputStream.close();
      } catch (IOException e) {
      }
    }
  }
```


在`XMLConfigBuilder` 之后，通过 parse.parse() 方法进行解析配置文件


```java
  public Configuration parse() {
    // 从XML文件中获取根目录的 configuration 节点
    parseConfiguration(parser.evalNode("/configuration"));
    return configuration;
  }

  private void parseConfiguration(XNode root) {
    try {
      // 配置变量参数
      propertiesElement(root.evalNode("properties"));
      // 配置设置参数
      Properties settings = settingsAsProperties(root.evalNode("settings"));
      loadCustomVfs(settings);
      loadCustomLogImpl(settings);
      // 配置类型别名
      typeAliasesElement(root.evalNode("typeAliases"));
      
      // 创建插件
      pluginElement(root.evalNode("plugins"));
      
      objectFactoryElement(root.evalNode("objectFactory"));
      objectWrapperFactoryElement(root.evalNode("objectWrapperFactory"));
      reflectorFactoryElement(root.evalNode("reflectorFactory"));
      settingsElement(settings);
      
      // 配置环境
      environmentsElement(root.evalNode("environments"));
      
      // 配置数据库提供商
      databaseIdProviderElement(root.evalNode("databaseIdProvider"));
      
      // 配置类型处理器
      typeHandlerElement(root.evalNode("typeHandlers"));
      
      // 配置Mapper
      mapperElement(root.evalNode("mappers"));
    } catch (Exception e) {
      throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);
    }
  }
```


### 解析 配置项(Properties)


从 MyBatis 的配置文件中就可以看出 有个标签类别为 `properties` 的 属性，常见的情况下，通常如下配置


```xml
  <properties>
    <property name="title" value="TITLE"/>
    <property name="age" value="17"/>
  </properties>
```


上面的代码中通过 `propertiesElement(root.evalNode("properties"));` 的主要作用就是解析出 **propterties** 标签的内容，具体的解释看注释。


```java
  private void propertiesElement(XNode context) throws Exception {
    // 如果配置文件中不存子 properties 字段属性，那么就不解析
    if (context != null) {
      // 获取Properties的内容，将其封装为 Properties，Properties继承了 Hashtable 
      // 可以粗略的认为 Properties 就是一个 KV 集合
      Properties defaults = context.getChildrenAsProperties();
      // 从Properties中获取到 resource属性和URL属性，尝试从其他资源中获取配置
      String resource = context.getStringAttribute("resource");
      String url = context.getStringAttribute("url");
      // 如果都指定了，则报错，必须明确的指定一个
      if (resource != null && url != null) {
        throw new BuilderException("The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.");
      }
      // 根据 resource或者URL 解析到新的Properties，Put 到 上面解析的结果中
      if (resource != null) {
        defaults.putAll(Resources.getResourceAsProperties(resource));
      } else if (url != null) {
        defaults.putAll(Resources.getUrlAsProperties(url));
      }
      // 获取其他的默认配置
      Properties vars = configuration.getVariables();
      if (vars != null) {
        defaults.putAll(vars);
      }
      //设置回Parse用于后续的解析使用
      parser.setVariables(defaults);
      //设置回Configuration中
      configuration.setVariables(defaults);
    }
  }
```


通过 `propertiesElement()` 方法就首先得解析出配置文件中配置的变量，并用于后续其他属性解析。


### 配置 设置项(Settings)


接下来的是解析settings，Setting是MyBatis的相关配置项，开发者可以通过此标签进行MyBatis相关控制以及相关选项的配置。比如一个简单的配置项如下


```xml
<settings>
  <setting name="cacheEnabled" value="false"/>
</settings>
```


其解析代码如下:


```java
  private Properties settingsAsProperties(XNode context) {
    if (context == null) {
      return new Properties();
    }
    Properties props = context.getChildrenAsProperties();
    // 获取支持的属性值
    MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);
    for (Object key : props.keySet()) {
      // 如果给定的属性值不属于 Configuration 内置的属性，则会抛出异常
      if (!metaConfig.hasSetter(String.valueOf(key))) {
        throw new BuilderException("The setting " + key + " is not known.  Make sure you spelled it correctly (case sensitive).");
      }
    }
    return props;
  }
```


可以看到，Setting的解析如果出现未知的配置项，则会抛出异常。那么通过  `Configuration` 可以看到允许的配置值.


```java
public class Configuration {

  protected Environment environment;

  protected boolean safeRowBoundsEnabled;
  protected boolean safeResultHandlerEnabled = true;
  protected boolean mapUnderscoreToCamelCase;
  protected boolean aggressiveLazyLoading;
  protected boolean multipleResultSetsEnabled = true;
  protected boolean useGeneratedKeys;
  protected boolean useColumnLabel = true;
  protected boolean cacheEnabled = true;
  protected boolean callSettersOnNulls;
  protected boolean useActualParamName = true;
  protected boolean returnInstanceForEmptyRow;
  protected boolean shrinkWhitespacesInSql;
  
  // .....
}
```


在Settings 解析完成之后，会返回一个Properties 用于其他的配置，比如配置


```java
// org/apache/ibatis/builder/xml/XMLConfigBuilder.java:107
Properties settings = settingsAsProperties(root.evalNode("settings"));
// 配置虚拟文件系统
loadCustomVfs(settings);
// 配置自定义的日志系统
loadCustomLogImpl(settings);
```


### 配置 类型别名(typeAliases)


类型别名是MyBatis中非常重要的一个概念, 它能够帮助开发者更简便的编写代码。类型别名的使用方式不再本文的讨论中，比如我们配置一个简单的别名如下


```xml
  <typeAliases>
    <!--   使用 package 的方式，按包指定-->
    <package name="com.zhoutao123.dao.model"/>
    <!--   或者使用下面的方式，单个指定-->
    <typeAlias type="org.mybatis.example.UserDO" alias="user"/>
  </typeAliases>
```


那么我们在书写Mapper的时候就可以直接这样使用


```xml
 <!--定义别名之前-->  
 <select id="find" resultType="org.mybatis.example.UserDO">
    SELECT * FROM user WHERE id = #{id}
 </select>

 <!--定义别名之后-->
  <select id="find" resultType="user">
    SELECT * FROM user WHERE id = #{id}
  </select>
```


可以通过 `typeAliasesElement` 查看类型别名的源码


```java
if (parent != null) {
  for (XNode child : parent.getChildren()) {
    // 如果指定了按包级别扫描别名，则通过 name 属性获取到需要扫描的包下的类
    if ("package".equals(child.getName())) {
      String typeAliasPackage = child.getStringAttribute("name");
      configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
    } else {
      // 如果不是按照包扫描别名则直接通过标签 typeAlias 的alias属性和 type 属性注册
      String alias = child.getStringAttribute("alias");
      String type = child.getStringAttribute("type");
      try {
        Class<?> clazz = Resources.classForName(type);
        // 如果别名为NULL，则根据策略生成一个alias, 生成范式参照  下面的 registerAlias(Class<?> type)
        if (alias == null) {
          typeAliasRegistry.registerAlias(clazz);
        } else {
          typeAliasRegistry.registerAlias(alias, clazz);
        }
      } catch (ClassNotFoundException e) {
        throw new BuilderException("Error registering typeAlias for '" + alias + "'. Cause: " + e, e);
      }
    }
  }
}

  public void registerAlias(Class<?> type) {
    // 获取类的简称
    String alias = type.getSimpleName();
    // 获取类上的Alias注解
    Alias aliasAnnotation = type.getAnnotation(Alias.class);
    // 如果注解存在，则使用注解的值作为别名，否则使用类的简称作为别名
    if (aliasAnnotation != null) {
      alias = aliasAnnotation.value();
    }
    registerAlias(alias, type);
  }
```


在最后，类型别名和类型的clazz 对象将被保存在 `typeAlias` 对象中, typeAliases 对象则是一个Map集合，用于保存 MyBatis系统中自定义的类型别名 


```java
 private final Map<String, Class<?>> typeAliases = new HashMap<>(); 

 public void registerAlias(String alias, Class<?> value) {
    if (alias == null) {
      throw new TypeException("The parameter alias cannot be null");
    }
    // issue #748
    String key = alias.toLowerCase(Locale.ENGLISH);
    if (typeAliases.containsKey(key) && typeAliases.get(key) != null && !typeAliases.get(key).equals(value)) {
      throw new TypeException("The alias '" + alias + "' is already mapped to the value '" + typeAliases.get(key).getName() + "'.");
    }
    typeAliases.put(key, value);
  }
```


众所周知，MyBatis 也内置一些常用的类型别名，比如 `string/int/boolean/map/list` 等，这些默认的别名也是通过 `registerAlias` 实现注册的，在 TypeAlias 的构造方法中可以看到相关的源码


```java
  public TypeAliasRegistry() {
    registerAlias("string", String.class);

    registerAlias("byte", Byte.class);
    registerAlias("long", Long.class);
    registerAlias("short", Short.class);
 
      // .... 省略部分

    registerAlias("map", Map.class);
    registerAlias("hashmap", HashMap.class);
    registerAlias("ResultSet", ResultSet.class);
  }
```


### 配置 插件(Plugin)
 插件可以说是对于MyBatis 使用的一个重要的分水岭，很多非常好用的MyBatis的插件都是使用Plugin实现的，比如 `PageHelp、MyBatais-Plus`。下面看看Plugin的配置方式吧


```xml
  <plugins>
    <plugin interceptor="org.mybatis.example.plugins.CustomerExecutor">
      <property name="limit" value="123"/>
      <property name="max" value="456"/>
    </plugin>
  </plugins>
```
上面的一段XML代码实现一个MyBatis 插件的注册 ， 而插件则必须是 `org.apache.ibatis.plugin.Intercepto` 的子类。
> 由于本文主要的重点是MyBatis流程的启动过程以及MyBatis配置的解析过程，所以MyBatis的插件开发将后再后续的文章通过案例（PageHelp）以源码解析的方式学习Plugin的开发。当然后面也会实现一个简单的案例



```java
for (XNode child : parent.getChildren()) {
  // 获取 <plugin> 标签的 interceptor 属性以及其属性值properties
  String interceptor = child.getStringAttribute("interceptor");
  Properties properties = child.getChildrenAsProperties();
    
  // 通过全类名解析出Class并获取其构造方式并创建一个新的实例  
  Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).getDeclaredConstructor().newInstance();
   
  // 为此实例设置properties
  interceptorInstance.setProperties(properties);
  
  // MyBatis 的 configuration中新增拦截器
  configuration.addInterceptor(interceptorInstance);
}
```