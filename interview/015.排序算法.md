### 简单排序算法

#### 冒泡排序法

+ 核心思想: 将第i个数字和第i+1个数字比较，如果比之大，那么则交换，每一次遍历完成后，最后一个为最大数
+ 时间复杂度: O(n^2)

![冒泡排序法](img/sort/bubble_img.png)

#### 选择排序法

+ 核心算法： 从中选出最小的数据，放在头部相应的位置，然后从剩下的部分中在选出最小的数据，依次类推，完成排序
+ 时间复杂度: O(n^2)

![img.png](img/sort/select_img.png)

#### 插入排序

+ 核心算法: 假定前面的是有序的，拿到新的数据后依次向左插入，直到遇到比他小的数据后停止，然后继续插入下个数据
+ 时间复杂度: O(n^2)

![img.png](img/sort/insert_img.png)

### 高级排序算法

#### 希尔排序

+ 核心算法: 分组-插入排序
+ 时间复杂度:  O(n^(1.3-2))

![img.png](img/sort/shell_img.png)

#### 归并排序

+ 核心算法: 分治算法
+ 时间复杂度: O(nlogn)

![img.png](img/sort/merge_img.png)

+ 时间复杂度计算


由代码结构可知 $$T(n)=T(\frac{n}{2}) + T(\frac{n}{2}) + O(n)$$ 即 $$T(n) = 2 * T(\frac{n}{2}) + O(1)$$

所以，两遍同时除以n可得  $$\frac{T(n)}{n} = \frac{T(\frac{n}{2})}{\frac{n}{2}} + O(1)$$

令 $$S(n)=\frac{T(n)}{n}$$

即$$S(n)=S(\frac{n}{2})+O(1)=S(\frac{n}{4})+O(2)=S(\frac{n}{8})+O(3)$$ 整理可知 $$S(n)=S(\frac{n}{2^k}) + O(k)$$

令$$S(\frac{n}{2^k})=S(1)$$ 可得 $$k=\log{n}$$

所以 $$S(n)=S(1) + O(\log(n)) = O(\log(n)) = \frac{T(n)}{n}$$可推导出 $$O(\log(n)) = \frac{T(n)}{n} => T(n) = n * \log(n)$$

即$$O(n) = O(n\log(n))$$


