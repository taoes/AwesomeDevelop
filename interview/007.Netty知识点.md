## Java NIO

使用 strace 命令追踪应用与Linux内核交互的代码逻辑,这里以BIO代码为示例

```shell
stracr -ff -o out [command] [args]
```

+ NIO 优势: 避免多线程的问题，C10K
+ NIO 劣势: 仍然是同步的线程模型，因为仍然需要程序自己去读IO，因此是同步的IO模型，

### 多路复用器的实现
 
多路复用器是内核实现的功能。 多路复用器只能提供链接的状态，具体读取数据还是由程序去读。


### select、poll 优劣势
+ 通过一次系统调用由内核进行遍历，减少了系统调用的次数
+ 每次调用系统方法，都会造成大量的fd重复传递(内核开辟空间，保存fd)
+ 每次select，poll 都需要重新遍历所有的连接

### epoll 详解

epoll的常用三个方法`epoll_create` , `epoll_ctl` 以及`epoll_wait`。

```java
Selector.open() // 实际上会调用 epoll_create() 方法
Service.register(selector,SelectionKey.OP_ACCEPT) //实际上会调用 epoll_ctl
selector.keys() // 实际上会调用 epoll_wait() 方法
```


## netty的线程模型

+ reactor单线程模型
用户发起io操作到事件分离器。事件分离器调用相应的处理器处理事件，事件处理完之后，事件分离器获得控制权，继续相应处理
+ reactor多线程模型
单线程中，每个io事件都在同一个线程中执行，当其中一个io出现异常时，将导致后面的io处理不了，
在多线程中，事件分离器中有reactorThreadacceptor和reactorThreadPool。reactorThreadacceptor接收到一个io事件，将io事件交于线程池处理，自己继续等待其他io事件。
+ reactor主从多线程模型。
Acceptor不再是一个线程，而是一个nio线程池。acceptor仅仅完成登录，握手，认证等，其他业务扔交给work线程池 NioEventLoop
1.作为服务端Acceptor线程，负责处理客户端的请求接入
2.作为客户端Connecor线程，负责注册监听连接操作位，用于判断异步连接结果
3.作为IO线程，监听网络读操作位，负责从SocketChannel中读取报文
4.作为IO线程，负责向SocketChannel写入报文发送给对方，如果发生写半包，会自动注册监听写事件，用于后续继续发送半包数据，直到数据全部发送完成



### Netty优势


使用io，性能跟不上，使用原生nio，复杂的API并不方便使用，搭建一套优秀的nio框架并不容易。使用现成的netty，节省开发时间，提高系统性能。



### 什么是TCP粘包/拆包

客服端发送了两个数据包，服务器端只收到了一个数据包。tcp协议不会出现丢包，说明两个数据包被粘在一起了，即为粘包。
客服端发送一个数据包，服务器端收到了两个数据包，即为拆包。
原因（为什么要粘包和拆包）
1.应用程序写入的数据大于套接字缓冲区大小，需要拆包
2.写入的数据小于套接字缓冲区大小，网卡将多次写入的数据发送到网络，发生粘包
3.接收方法不及时读取套接字缓冲区数据，发生粘包。


+ 解决方式

1.发送端给每个数据包添加包首部。首部中应该包含数据包的长度，这样在接受端通过读取包首部，便能准确地读到有用的数据
2.发送端将数据包封装为固定长度，不够补齐0，接受端再读取固定长度的数据，便能准确将粘包的数据进行拆包。
3.在数据包设置边界，添加特殊字符，这样便能够通过特殊字符进行拆分。



### netty的心跳处理在弱网下怎么办

在一定时间内，没有数据交互，即处于 idle 状态时，客服端或服务器端会发送一个数据给对方，即ping-pong，当某一端收到消息后，即证明tcp连接仍然存在。

### netty的通讯协议是什么样的

TCP粘包的解决方案
1.固定消息长度，不够补0
2.在不是同一个数据包之间设置特殊字符
3.不定长报文，包首部包含数据的长度。

