### netty的线程模型

+ reactor单线程模型
用户发起io操作到事件分离器。事件分离器调用相应的处理器处理事件，事件处理完之后，事件分离器获得控制权，继续相应处理
+ reactor多线程模型
单线程中，每个io事件都在同一个线程中执行，当其中一个io出现异常时，将导致后面的io处理不了，
在多线程中，事件分离器中有reactorThreadacceptor和reactorThreadPool。reactorThreadacceptor接收到一个io事件，将io事件交于线程池处理，自己继续等待其他io事件。
+ reactor主从多线程模型。
Acceptor不再是一个线程，而是一个nio线程池。acceptor仅仅完成登录，握手，认证等，其他业务扔交给work线程池 NioEventLoop
1.作为服务端Acceptor线程，负责处理客户端的请求接入
2.作为客户端Connecor线程，负责注册监听连接操作位，用于判断异步连接结果
3.作为IO线程，监听网络读操作位，负责从SocketChannel中读取报文
4.作为IO线程，负责向SocketChannel写入报文发送给对方，如果发生写半包，会自动注册监听写事件，用于后续继续发送半包数据，直到数据全部发送完成



### Netty优势


使用io，性能跟不上，使用原生nio，复杂的API并不方便使用，搭建一套优秀的nio框架并不容易。使用现成的netty，节省开发时间，提高系统性能。



### 什么是TCP粘包/拆包

客服端发送了两个数据包，服务器端只收到了一个数据包。tcp协议不会出现丢包，说明两个数据包被粘在一起了，即为粘包。
客服端发送一个数据包，服务器端收到了两个数据包，即为拆包。
原因（为什么要粘包和拆包）
1.应用程序写入的数据大于套接字缓冲区大小，需要拆包
2.写入的数据小于套接字缓冲区大小，网卡将多次写入的数据发送到网络，发生粘包
3.接收方法不及时读取套接字缓冲区数据，发生粘包。

#### 解决方式

1.发送端给每个数据包添加包首部。首部中应该包含数据包的长度，这样在接受端通过读取包首部，便能准确地读到有用的数据
	2.发送端将数据包封装为固定长度，不够补齐0，接受端再读取固定长度的数据，便能准确将粘包的数据进行拆包。
	3.在数据包设置边界，添加特殊字符，这样便能够通过特殊字符进行拆分。



### netty的心跳处理在弱网下怎么办

在一定时间内，没有数据交互，即处于 idle 状态时，客服端或服务器端会发送一个数据给对方，即ping-pong，当某一端收到消息后，即证明tcp连接仍然存在。

### netty的通讯协议是什么样的

TCP粘包的解决方案
1.固定消息长度，不够补0
2.在不是同一个数据包之间设置特殊字符
3.不定长报文，包首部包含数据的长度。

