## 集合

#### 1、List

+ ArrayList: 基于数组实现,初始值10, 每次新增元素的时候回检查容器是够足够，不够则话会扩容到原来的1.5倍，支持RandomRead,时间负责度O(1),读取快，增删慢
+ LinkedList: 基于双线链表实现，线程不安全，查找慢，增删快，比ArrayList更占内存，每个元素上多了两个指针引用
+ HashSet: 底层基于HashMap实现，线程不安全，添加的变量作为KEY，值是一个常量的Object类
+ HashMap: 底层基于数组+链表或数组+红黑树实现,线程不安全，初始化容量为16，负载因子0.75 当添加元素时候，数组的长度小于64并且某个数组的链表长度大于8的时候，就是说只有在数组长度大于64并且链表长度大于8的时候，才会转换为红黑树
+ TreeMap: 底层基于红黑树实现，保证有序
+ HashTable: 线程安全，不支持KEY和VALUE为NULL，使用 synchronized(this) 关键声明为线程安全
+ ConcurrentHashMap: 线程安全，不支持KV为NULL，使用 synchronize(Node) 和 CAS 方式保证安全, JDK7 使用分段锁的方式保证线程安全

## 并发



### 字符串

+ String: final修饰的变量，创建后不可修改，JDK8时候底层使用 char[] 实现，JDK9时候使用byte[] 实现
+ StringBuffer和StringBuild都是用来创建String的，底层使用的char[] 实现，使用final修饰，不可被继承
+ StirngBuffer 线程安全，使用synchronized(this) 实现 ，底层使用char[] 实现
+ StringBuild 线程不安全 ，底层使用char[] 实现





### 类加载

1. Class.forName(String classPathName) 和 ClassLoad.loadClass 有什么区别?

   > 1. 前者使用当前调用者的类加载器，后者使用指定类加载器加载
   >
   > 2. 前者参数中有链接的参数，默认为true,将执行链接(验证,准备,解析)，所以无法执行静态代码块