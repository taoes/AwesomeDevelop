[[toc]]

## 1. 消息队列的使用场景

消息队列主要是为了解决应用耦合，异步消息，流量削峰等问题，实现高性能，高可用，可伸缩和最终一致性架构。消息队列：ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。

## 2. 消息的重发，补充策略

在MQ中，当消费者消费消息产生异常时, 消费者会把消息放入一个特殊队列中, 进行下次处理，这就是消息的重发

## 3. 如何保证消息的有序性

消息队列的底层数据实现便是队列，先进先出，便保证了消息的有序性

## 4. 用过哪些MQ，和其他mq比较有什么优缺点

ActiveMQ，RabbitMQ,Kafka,RocketMQ,ZeroMQ

- RabbitMQ：采用Erlang语言实现的AMQP协议的消息中间件。优点，可靠性，可用性，扩展性，功能丰富。
- Kafka：一个分布式/多分区/多副本基于zookeeper协调的分布式消息系统、高吞吐量的分布式发布订阅消息系统。

## 5. MQ系统的数据如何保证不丢失

1.消息持久化
   + Exchange 设置持久化
   + Queue设置持久化
   + Message持久化发送，发送消息设置发送模式deliveryMode=2，代表持久化消息

2. ACK确认机制
   消费端消费完成时需要通知服务端，服务端才把消息从内存中删除

3. 设置集群镜像模式

## 6. RabbitMQ 实现高可用
RabbitMQ分为3种模式 单一模式（非集群模式）、普通模式（默认的集群模式）、镜像模式

## 7、kafka吞吐量高的原因
1. 顺序读写
2. 零拷贝
3. 分区
4. 批量发送
5. 数据压缩


## 8、kafka 和其他消息队列的区别，kafka 主从同步怎么实现
+ 高性能跨语言分布式发布/订阅消息队列系统
+ 快速持久化，可以在O(1)的系统开销下进行消息持久化；
+ 高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；
+ 完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；
+ 支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。
+ 一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。


## 9、MQ有可能发生重复消费，如何避免，如何做到幂等
比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。

比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。

比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据







