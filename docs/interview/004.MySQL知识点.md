[[toc]]

## 事务

#### ACID 特性
+ 原子性： 要么全部成功，要么全部失败
+ 一致性： 事务只能从一种一致性状态转换到另外一种一致性状态
+ 持久性： 事务一旦提交之后，就会持久化到磁盘介质上
+ 隔离性： 事务与事务之间具有隔离的特性

### 隔离级别
+ 读未提交: 无法解决 脏读、不可重复度以及幻读
+ 读已提交： 无法解决脏读 &不可重复度【Oracle默认】
+ 可重复读： 无法解决脏读【MYSQL默认】
+ 串行化：解决所有问题，但性能较低

::: warning
 隔离级别实现方式: 读写锁 + MVCC
:::

#### Innodb 实现 MVCC的方式
1. 每行记录都有一个版本号
2. InnoDB通过X锁的方式锁定行
3. 将元数据拷贝到Undo Log，通过引用的方式指向undolog 中的元数据
4. 修改行记录版本号

### ACID 特性实现原理
1. 原子性由 undo log 保证，记录了未被修改的数据，当回滚的时候，使用undo log 实现回滚
2. 一致性 一般由代码层实现
3. 隔离性有版本号实现，即MVCC （Multi Version Concurrent  Controller 多版本并发控制）
4. 持久性由 内存 + redolog 实现  事务提交时候通过redo log 刷盘，宕机时候通过 redo log 恢复数据

## 存储引擎

### InnoDB
InnoDB 存储引擎支持外键、聚簇索引、事务、行级锁、表级锁. 插入缓存、二次写、自适应Hash索引 以及预读. 在锁机制中锁机制支持:
+ 共享锁（S锁）即读取的时候不能修改，实现方式 LOCK IN SHARE MODE；
+ 同时也支持排它锁(X) 写的时候不能读也不能写，实行方式 版本号(乐观锁) 或者 FOR UPDATE(悲观锁);
+ 间隙锁 （Gap Lock）未解决幻读的一种方式
+ 锁的算法:  Record Key、Gap Key & Next-Key Lock
+ 锁的特点: 行级锁:占用更多的内存，在表大量使用的时候，因为要获取指定的行锁，所以速度较慢仅仅锁定部分数据、可以长时间的锁定某一行

### InnoDB的索引
采用自增ID作为PK,每个数据表都有一个默认的PK,索引被记录在B+树上，如果使用整型作为主键会自动的插入后续问题之,如果不使用自增主键，则插入的数据可能会乱，造成大量的不连续的空间，造成表文件很大

#### BTREE索引和HASH索引

1. BTREE索引更好地减少查询次数和IO次数，通过变种的BTREE索引更好地支持范围查找
2. HASH索引比BTREE更快，但应用场景有限，不支持最左匹配，仅支持 等于 IN 等操作
3. BTREE索引会适当的冗余数据并且完整的保存了整条数据，通过ID查询不会再次的进行回表操作
4. HASH 等值查询的效率较低，尤其是出现大量冲突的情况,在InnoDB的监控预测下，如果发现Hash索引效率更高，则会默认转换为Hash索引

#### 不适合创建索引的情况
1. 数据量少
2. 大量写少量读的情况
3. 大量重复数据的列

### InnoDB的日志

误日志，查询日志，慢查询日志，binlog日志以及中继日志,undo log  & redo log

### MyISAM 索引

+ 不支持聚簇索引，索引文件 MYI 和 数据文件 MYD 不再同一个文件中，因此不支持聚簇索引
+ 仅支持表级锁，不支持行级锁 、 不支持外键

### Memory 索引
内存型存储引擎，重启后丢失数据，适合临时计算的保存

## SQL语句种类

+ DDL 数据库定义语言
+ DML 数据库操作语言
+ DCL 数据库控制语言
+ TCL 事务控制语言

## MySQL性能优化


### 分表
+ 垂直分表: 一个表中热点数据和非热点数据进行拆分
+ 水平分表: 通过将某个字段自动hash的方式实现水评分表
> 水平分表的ID方案: 设置不同步长的自增，分布式ID服务 & 自增雪花算法生成

### 分库: 
MyCAT 等中间件实现分库

### 主从同步
同步方式基于 bin log实现， BinLog的日志格式分为： Statement、RAW 以及 Mixed

+ RAW: 记录变动记录，不会造成数据不一致的问题,数据量较大，尤其是ALTER或者批量修改的时候
+ Statement: 记录SQL语句,简单, 数据量小,无法处理 CURRENT_DATE() /RAND() 造成数据不一致的问题
+ Mixed： 即Statemtn + RAW 的混合模式，一般语句使用Statement记录，对于一些函数使用RAW记录

### 主从同步的方式
+ 全同步复制(类似于ZK的CP的方式，所有从服务器成功后再返回客户端)
+ 半同步复制(主服务器接收到至少一个从服务器的ACK确认后任务成功)

### 架构原因以及问题
+ 主从同步的原因是分担读压力
+ 主从同步的问题: 数据一致性问题（最终一致性）

### 同步过程
1. Master 将已提交的事务记录写入binlog
2. Slaver 配置主服务器，拉取binlog
3. Master 创建dump线程，将binlog 推给slave
4. Slaver创建IO线程，读取同步过来的reply log
5. salver 开启新的线程处理 reply log 
6. salver 记录自己的 binlog 日志


### 慢查询的优化方式
+ 限制范围查询，比如6个月内
+ 主从同步、读写分离
+ 上级拦截，缓存机制
+ 垂直分表/水平分表
+ 执行计划
+ 索引SQL优化
