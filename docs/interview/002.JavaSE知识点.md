[[toc]]

### 集合特性

+ ArrayList: 基于数组实现,初始值10, 每次新增元素的时候回检查容器是够足够，不够则话会扩容到原来的1.5倍，支持RandomRead,时间负责度O(1),读取快，增删慢
+ LinkedList: 基于双线链表实现，线程不安全，查找慢，增删快，比ArrayList更占内存，每个元素上多了两个指针引用
+ HashSet: 底层基于HashMap实现，线程不安全，添加的变量作为KEY，值是一个常量的Object类
+ HashMap: 底层基于数组+链表或数组+红黑树实现,线程不安全，初始化容量为16，负载因子0.75 当添加元素时候，数组的长度小于64并且某个数组的链表长度大于8的时候，就是说只有在数组长度大于64并且链表长度大于8的时候，才会转换为红黑树
+ TreeMap: 底层基于红黑树实现，保证有序
+ HashTable: 线程安全，不支持KEY和VALUE为NULL，使用 synchronized(this) 关键声明为线程安全
+ ConcurrentHashMap: 线程安全，不支持KV为NULL，使用 synchronize(Node) 和 CAS 方式保证安全, JDK7 使用分段锁的方式保证线程安全


#### 快速失败(FastFail) 与 安全失败(SafeFail)

+ 快速失败
  迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。
  
+ 安全失败
  采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。
  
>缺点：基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

#### HashMap为什么使用红黑树而不是AVL？
   + AVL以及红黑树是高度平衡的树数据结构。它们非常相似，真正的区别在于在任何添加/删除操作时完成的旋转操作次数。
   + 两种实现都缩放为a O(lg N)，其中N是叶子的数量，但实际上AVL树在查找密集型任务上更快：利用更好的平衡，树遍历平均更短。另一方面，插入和删除方面，AVL树速度较慢：需要更高的旋转次数才能在修改时正确地重新平衡数据结构。
   + 在AVL树中，从根到任何叶子的最短路径和最长路径之间的差异最多为1。在红黑树中，差异可以是2倍。
   + 两个都给O（log n）查找，但平衡AVL树可能需要O（log n）旋转，而红黑树将需要最多两次旋转使其达到平衡（尽管可能需要检查O（log n）节点以确定旋转的位置）。旋转本身是O（1）操作，因为你只是移动指针。


## 并发

### 字符串

+ String: final修饰的变量，创建后不可修改，JDK8时候底层使用 char[] 实现，JDK9时候使用byte[] 实现
+ StringBuffer和StringBuild都是用来创建String的，底层使用的char[] 实现，使用final修饰，不可被继承
+ StirngBuffer 线程安全，使用synchronized(this) 实现 ，底层使用char[] 实现
+ StringBuild 线程不安全 ，底层使用char[] 实现


### 类加载

1. Class.forName(String classPathName) 和 ClassLoad.loadClass 有什么区别?

   > 1. 前者使用当前调用者的类加载器，后者使用指定类加载器加载
   >
   > 2. 前者参数中有链接的参数，默认为true,将执行链接(验证,准备,解析)，所以无法执行静态代码块