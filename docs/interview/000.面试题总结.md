### 电话面

+ 介绍下你所知道的多线程
+ 如何等待多线程完成？
+ AOP的应用场景和实现原理
+ 问了下项目的架构设计
+ 消息队列的应用场景

### 一面

+ 消息队列怎么不丢数据

+ DDD领域模型

+ 限流算法

> 漏桶算法

+ MySQL的索引实现以及先关的使用场景，最左匹配原则的实现原理

> 哈希索引，B+树索引

+ Volatile的实现原理

> LOCK 指令, 参考笔者的文章[Volatile 的应用和实现](https://www.zhoutao123.com/page/book/concurrent/category/ifsuq2?bookId=11)

+ 公平锁和非公平锁的实现原理

> AQS 队列 [Lock与AbstractQueueSynchronizer ](https://www.zhoutao123.com/page/book/concurrent/category/uumw7h?bookId=11)

+ ThreadLocal 的实现以及为什么要用弱引用

> 线程持有一个类似的Map的数据结构，其中的KEY就是 ThreadLocal 对象，Value就是相应的值

+ CountDownLatch 的使用以及原理

> 内部有一个volatile的变量，保证了对多线程及时可见

+ 讨论了一些应用场景，比如我们之前用的延时任务的实现方式

> 可以参考笔者之前的文章 [延时任务的最佳实践](https://www.zhoutao123.com/page/book/architect/category/pzqaap?bookId=2)

+ 线程安全的实现方式

> 锁,synchronized, CAS, 拷贝时复制

+ ES 的使用方式

> 同步数据到ES，

+ 简述下CAP理论，ZK实现了CP还是AP，试说明ZK是CP的原因

> 可用性，一致性，分区容错性

> ZK实现了CP，Redis实现AP，ZK在写入数据的时候要求所有节点均写入完成后再返回，因此是CP，而Redis和MySQL仅仅写入到主节点，然后通过主节点和从节点同步的方式达到最终一致性

+ RabbitMQ的交换类型

> direct,topic,fanout,header

+ 问了我们系统的微服务发展方案

### 二面
+ 介绍项目信息, 说一说项目中的挑战
> 巴拉巴拉

+ 线程池各个参数的含义，以及你们系统中这些参数配置的哪些值？
> 核心线程数，最大线程数，线程保持时间，任务队列，丢弃策略 

+ 线程池的使用，对于有返回值的任务放在线程池运行如何获取返回值？
> 线程池 commit() 任务不会有返回值, submit(Task) 则会有返回Future ，可以通过Future获取任务执行完成后的返回值

+ 有1亿个手机号码，如何选择重复最多的前100个号码?
> 使用ForkJoin分割任务为小任务，例如划分到1万个数据时候，在1W个数据里面找到前100个重复的

+ 那么在1W个数据里面找到重复率最大的数据使用哪种数据结构？
> 在提醒的情况下，说出 散列 + 最大堆


+ 如何在最大堆中插入数据？
> 将数据插入到尾部，然后重构该节点的父节点做heapify操作，迭代调用，直到最顶部节点


+ 对于秒杀系统，如何保证不超卖(假设有N个商品)？
> 1. 锁，把并行的请求转换为串行，效率低
> 2. CAS
> 3. 将数据落入到Redis中，通过Redis的原子化操作写入N个商品，后续的不在写入，然后在将数据落入到DB 中

+ Redis集群中如何保证数据不丢失
> 对于集群则可能会出现数据丢失的问题，比如M还没来得及同步到S的时候，M宕机，这种情况的解决方案，可以使用奇数个Redis服务器，当写入 一半的服务都成功的时候，即任务成功，这样可以确保数据不丢失 ,其实就是 **RedLock**

+ InnoDB 为什么使用B+树？
> B+树的叶子节点通过链表连接，可以很方便的进行范围查找

+ InnoDB 的B+树一般有几层，怎么计算的？
> 一般情况下3层就可以实现千万级的行记录，说通过数据页，16kb啥的，迷迷糊糊糊弄过去 ；）


+ 对于InnoDB的数据库，A表有个联合索引，[k1,k2,k3,k4], 那么下面的查询语句中有何区别？

```sql
-- SQL 1
select  * FROM A WHERE k1='1';

-- SQL2
select id FROM A WHERE k1='1';

-- SQL3
select k2 FROM A WHERE k1='1';
```

> 1. 由于InnoDB 支持聚集索引，上面的索引显然是非聚集索引，所以会先查询到行记录的ID，然后通过ID在主键索引中查询到具体数据。这种现象称之为回表
> 2. SQL1中是非聚集索引，查询到ID之后就回表查询数据
> 2. SQL2 的查询中，由于只会获取ID，所以不会需要回表操作
> 3. 同样的SQL3 中由于 k2 已经在索引中了，所以也不需要回表查询

### K8S 简单的概念













