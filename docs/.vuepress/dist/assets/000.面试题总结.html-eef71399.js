import{_ as a,r as t,o as i,c,a as l,d as e,b as n,e as s}from"./app-d035ab8f.js";const u={},r=s('<h3 id="电话面" tabindex="-1"><a class="header-anchor" href="#电话面" aria-hidden="true">#</a> 电话面</h3><ul><li>介绍下你所知道的多线程</li><li>如何等待多线程完成？</li><li>AOP的应用场景和实现原理</li><li>问了下项目的架构设计</li><li>消息队列的应用场景</li></ul><h3 id="一面" tabindex="-1"><a class="header-anchor" href="#一面" aria-hidden="true">#</a> 一面</h3><ul><li><p>消息队列怎么不丢数据</p></li><li><p>DDD领域模型</p></li><li><p>限流算法</p></li></ul><blockquote><p>漏桶算法</p></blockquote><ul><li>MySQL的索引实现以及先关的使用场景，最左匹配原则的实现原理</li></ul><blockquote><p>哈希索引，B+树索引</p></blockquote><ul><li>Volatile的实现原理</li></ul>',8),p={href:"https://www.zhoutao123.com/page/book/concurrent/category/ifsuq2?bookId=11",target:"_blank",rel:"noopener noreferrer"},k=l("ul",null,[l("li",null,"公平锁和非公平锁的实现原理")],-1),d={href:"https://www.zhoutao123.com/page/book/concurrent/category/uumw7h?bookId=11",target:"_blank",rel:"noopener noreferrer"},b=l("ul",null,[l("li",null,"ThreadLocal 的实现以及为什么要用弱引用")],-1),h=l("blockquote",null,[l("p",null,"线程持有一个类似的Map的数据结构，其中的KEY就是 ThreadLocal 对象，Value就是相应的值")],-1),q=l("ul",null,[l("li",null,"CountDownLatch 的使用以及原理")],-1),_=l("blockquote",null,[l("p",null,"内部有一个volatile的变量，保证了对多线程及时可见")],-1),m=l("ul",null,[l("li",null,"讨论了一些应用场景，比如我们之前用的延时任务的实现方式")],-1),v={href:"https://www.zhoutao123.com/page/book/architect/category/pzqaap?bookId=2",target:"_blank",rel:"noopener noreferrer"},f=s(`<ul><li>线程安全的实现方式</li></ul><blockquote><p>锁,synchronized, CAS, 拷贝时复制</p></blockquote><ul><li>ES 的使用方式</li></ul><blockquote><p>同步数据到ES，</p></blockquote><ul><li>简述下CAP理论，ZK实现了CP还是AP，试说明ZK是CP的原因</li></ul><blockquote><p>可用性，一致性，分区容错性</p></blockquote><blockquote><p>ZK实现了CP，Redis实现AP，ZK在写入数据的时候要求所有节点均写入完成后再返回，因此是CP，而Redis和MySQL仅仅写入到主节点，然后通过主节点和从节点同步的方式达到最终一致性</p></blockquote><ul><li>RabbitMQ的交换类型</li></ul><blockquote><p>direct,topic,fanout,header</p></blockquote><ul><li>问了我们系统的微服务发展方案</li></ul><h3 id="二面" tabindex="-1"><a class="header-anchor" href="#二面" aria-hidden="true">#</a> 二面</h3><ul><li>介绍项目信息, 说一说项目中的挑战</li></ul><blockquote><p>巴拉巴拉</p></blockquote><ul><li>线程池各个参数的含义，以及你们系统中这些参数配置的哪些值？</li></ul><blockquote><p>核心线程数，最大线程数，线程保持时间，任务队列，丢弃策略</p></blockquote><ul><li>线程池的使用，对于有返回值的任务放在线程池运行如何获取返回值？</li></ul><blockquote><p>线程池 commit() 任务不会有返回值, submit(Task) 则会有返回Future ，可以通过Future获取任务执行完成后的返回值</p></blockquote><ul><li>有1亿个手机号码，如何选择重复最多的前100个号码?</li></ul><blockquote><p>使用ForkJoin分割任务为小任务，例如划分到1万个数据时候，在1W个数据里面找到前100个重复的</p></blockquote><ul><li>那么在1W个数据里面找到重复率最大的数据使用哪种数据结构？</li></ul><blockquote><p>在提醒的情况下，说出 散列 + 最大堆</p></blockquote><ul><li>如何在最大堆中插入数据？</li></ul><blockquote><p>将数据插入到尾部，然后重构该节点的父节点做heapify操作，迭代调用，直到最顶部节点</p></blockquote><ul><li>对于秒杀系统，如何保证不超卖(假设有N个商品)？</li></ul><blockquote><ol><li>锁，把并行的请求转换为串行，效率低</li><li>CAS</li><li>将数据落入到Redis中，通过Redis的原子化操作写入N个商品，后续的不在写入，然后在将数据落入到DB 中</li></ol></blockquote><ul><li>Redis集群中如何保证数据不丢失</li></ul><blockquote><p>对于集群则可能会出现数据丢失的问题，比如M还没来得及同步到S的时候，M宕机，这种情况的解决方案，可以使用奇数个Redis服务器，当写入 一半的服务都成功的时候，即任务成功，这样可以确保数据不丢失 ,其实就是 <strong>RedLock</strong></p></blockquote><ul><li>InnoDB 为什么使用B+树？</li></ul><blockquote><p>B+树的叶子节点通过链表连接，可以很方便的进行范围查找</p></blockquote><ul><li>InnoDB 的B+树一般有几层，怎么计算的？</li></ul><blockquote><p>一般情况下3层就可以实现千万级的行记录，说通过数据页，16kb啥的，迷迷糊糊糊弄过去 ；）</p></blockquote><ul><li>对于InnoDB的数据库，A表有个联合索引，[k1,k2,k3,k4], 那么下面的查询语句中有何区别？</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- SQL 1</span>
<span class="token keyword">select</span>  <span class="token operator">*</span> <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> k1<span class="token operator">=</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">;</span>

<span class="token comment">-- SQL2</span>
<span class="token keyword">select</span> id <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> k1<span class="token operator">=</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">;</span>

<span class="token comment">-- SQL3</span>
<span class="token keyword">select</span> k2 <span class="token keyword">FROM</span> A <span class="token keyword">WHERE</span> k1<span class="token operator">=</span><span class="token string">&#39;1&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><ol><li>由于InnoDB 支持聚集索引，上面的索引显然是非聚集索引，所以会先查询到行记录的ID，然后通过ID在主键索引中查询到具体数据。这种现象称之为回表</li><li>SQL1中是非聚集索引，查询到ID之后就回表查询数据</li><li>SQL2 的查询中，由于只会获取ID，所以不会需要回表操作</li><li>同样的SQL3 中由于 k2 已经在索引中了，所以也不需要回表查询</li></ol></blockquote><h3 id="k8s-简单的概念" tabindex="-1"><a class="header-anchor" href="#k8s-简单的概念" aria-hidden="true">#</a> K8S 简单的概念</h3>`,35);function w(g,y){const o=t("ExternalLinkIcon");return i(),c("div",null,[r,l("blockquote",null,[l("p",null,[e("LOCK 指令, 参考笔者的文章"),l("a",p,[e("Volatile 的应用和实现"),n(o)])])]),k,l("blockquote",null,[l("p",null,[e("AQS 队列 "),l("a",d,[e("Lock与AbstractQueueSynchronizer "),n(o)])])]),b,h,q,_,m,l("blockquote",null,[l("p",null,[e("可以参考笔者之前的文章 "),l("a",v,[e("延时任务的最佳实践"),n(o)])])]),f])}const L=a(u,[["render",w],["__file","000.面试题总结.html.vue"]]);export{L as default};
