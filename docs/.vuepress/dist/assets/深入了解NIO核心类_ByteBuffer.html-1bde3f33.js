import{_ as p,r as o,o as c,c as i,a as n,d as s,b as e,e as a}from"./app-d035ab8f.js";const l="/assets/buffer_extends-e80c3b9f.png",u="/assets/buffer_index_relatation-f47eb47b.png",r="/assets/buffer_index_copy-64d35666.png",k="/assets/buffer_cache_fill-0e7b0731.png",d="/assets/buffer_cache_relaver_before-33fcd56f.png",f="/assets/buffer_cache_flip_after-4e47e51b.png",b="/assets/buffer_cache_release-b7acf87c.png",m={},v=a('<p>**<br>**ByteBuffer主要用于NIO操作中的数据缓存。**其位于<code>java.nio</code> 包下，一个Buffer对象是固定数量的数据的容器。其作用是一个存储器，或者分段运输区，在这里数据可被存储并在之后用于检索。缓存区ByteBuffer 与通道 Channel联系密切，通道Channel是发生IO操作时候的入口，而缓存区则是数据的来源或者目标_。<em>ByteBuffer 相对于 IO系统中的 InputStream或者OutputStream而言最大的区别是Buffer既可以读也可以写，所以在Buffer读写切换之前需要非常重要翻转操作(文章的后续会着重讲解Buffer的翻转以及其底层实现)。<br></em><br></p><p><img src="'+l+'" alt="img.png"></p><h2 id="buffer-基础概念" tabindex="-1"><a class="header-anchor" href="#buffer-基础概念" aria-hidden="true">#</a> Buffer 基础概念</h2><ul><li>容量(Capacity): 缓<strong>存</strong>区能够容纳的数据元素的最大数量。这一容量在缓<strong>存</strong>区创建时被设定，并且永远不能被改变。</li><li>上界(Limit): 缓<strong>存</strong>区的第一个不能被读或写的元素。或者说，缓<strong>存</strong>区中现存元素的计数。</li><li>位置(position): 下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。</li><li>标记(mark): 一个备忘位置。调用 mark( )来设定 mark = postion。调用 reset( )设定 position = mark。标记在设定前是未定义的(undefined)。</li></ul><p><br>这四者的关系是 <code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code> 如下所示<br></p><p><img src="'+u+`" alt="Buffer 索引关系"></p><h2 id="缓存区的创建" tabindex="-1"><a class="header-anchor" href="#缓存区的创建" aria-hidden="true">#</a> 缓存区的创建</h2><p><br>如同上图中所示 Buffer有不同的实现类，每一种都是对Java原始类型的封装。下面将就ByteBuffer对缓存区的创建进行分析解读。其他Buffer都是类似的实现，读者可以自行阅读相关源码学习了解。<br><br>新的缓存区是由系统分配或者包装而来的。比如下面的代码就是分别从直接内存中以及从堆内存中创建的ByteBuffer<br></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 在堆内存中申请的ByteBuffer,其实际类型为 HeapByteBuffer</span>
<span class="token comment">// 其底层支持为 byte[] </span>
<span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
<span class="token comment">// 在直接内存中申请的ByteBuffer,其实际类型为 DirectByteBuffer</span>
<span class="token comment">// 其底层是直接使用C++的内存申请函数实现的</span>
buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 通过包装的方式创建ByteBuffer，显然通过这种方式创建的ByteBuffer肯定是HeapByteBuffer</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token string">&quot;Hello,Java ByteBuffer&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><br>另外也可以通过API进行缓存区的复制 <code>duplicate()</code>，这里的复制值得是浅复制，其共享内存数据，其中一个缓存区对于数据的修改都会反映到另外一个缓存区上，但是两者具有不同的索引值。复制完成后两者具有相同的索引值, 源码中也说明了这一点</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ByteBuffer</span> <span class="token function">duplicate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HeapByteBuffer</span><span class="token punctuation">(</span>hb<span class="token punctuation">,</span>
                            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">markValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                            offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+r+`" alt=""></p><p><a name="BuSIk"></a></p><h2 id="缓存区的api" tabindex="-1"><a class="header-anchor" href="#缓存区的api" aria-hidden="true">#</a> 缓<strong>存</strong>区的API</h2><p><br>缓<strong>存</strong>区有以下的API，下面将通过源码的方式逐一讲解各个API的作用<br></p><ul><li>_public final int _capacity() 方法 返回Buffer的容量大小</li><li>_public final int _position() 返回下一个要被读或者写的元素的索引</li><li>_public final _Buffer position(_int _newPosition) 重新设定 position 的索引</li><li>_public final int _limit() 返回读或者写的上限</li><li>_public final _Buffer mark() 记录下position的索引值到mark上，当使用reset的时候将恢复position的值</li><li>_public final _Buffer reset() 恢复 position的索引值</li><li>_public final _Buffer clear() 清除缓<strong>存</strong>区的数据，注意这里并非真的清除，而是通过限制索引的方式使之不可读</li><li>_public final _Buffer flip() 翻转读写，当写完数据后，position指向的是下一个写的索引，要进行的读的话需要将positon 重置，反之亦然</li><li>_public final int _remaining() 返回有效的数据长度，即 limit - position</li><li>_public final boolean _hasRemaining() 返回的布尔值代表是否有有效的数据<br></li></ul><blockquote><p>对于部分的实现缓<strong>存</strong>区其是只允许读操作的，如果执行写操作将会抛出 java.nio.ReadOnlyBufferException#ReadOnlyBufferException 异常</p></blockquote><p><a name="RSRnP"></a></p><h2 id="缓存区的读写操作分析" tabindex="-1"><a class="header-anchor" href="#缓存区的读写操作分析" aria-hidden="true">#</a> 缓存区的读写操作分析</h2><p><br>在缓存区准备好之后，程序代码可以对缓<strong>存</strong>区进行读写操作，ByteBuffer 对于读写操作，内部的细节都是 <code>position,limit以及 mark</code> 的变动，下面笔者将从源码的角度对ByteBuffer 的各个操作进行分析。 <a name="InAXg"></a></p><h3 id="缓存区的读取" tabindex="-1"><a class="header-anchor" href="#缓存区的读取" aria-hidden="true">#</a> 缓存区的读取</h3><p><br>缓存区的读取主要以来的API有 <code>get() &amp; get(int index)</code>方法，其源码如下:<br></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// HeapByteBuffer#get()</span>
<span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hb<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">byte</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> hb<span class="token punctuation">[</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">nextGetIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">byte</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> hb<span class="token punctuation">[</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">checkIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// DirectByteBuffer#get() </span>
<span class="token keyword">public</span> <span class="token keyword">byte</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// unsafe.getByte() 方法为native方法</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">nextGetIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>



<span class="token comment">// 返回索引然后position值加1</span>
<span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">nextGetIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// package-private</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&gt;=</span> limit<span class="token punctuation">)</span>
     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BufferUnderflowException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> position<span class="token operator">++</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,23),y=n("br",null,null,-1),h=n("code",null,"java.nio.HeapByteBuffer",-1),g=n("code",null,"java.nio.DirectByteBuffer",-1),B={href:"https://www.zhoutao123.com/page/book/8",target:"_blank",rel:"noopener noreferrer"},_=a(`<blockquote><p>另外从源码<code>nextGetIndex()</code> 方法中也可以看得非常清楚，在 <code>get()</code> 操作完成之后 position 的索引会顺序的+1，而<code>get(int index)</code> 则不会跳动索引的值, 实际的编程中要特别的注意这一点。</p></blockquote><p><a name="46cd09ee"></a></p><h3 id="缓存区的填充" tabindex="-1"><a class="header-anchor" href="#缓存区的填充" aria-hidden="true">#</a> 缓存区的填充</h3><p>上面讲到了ByteBuffer的读取，这一段将阐述ByteBuffer的填充，即对ByteBuffer进行写操作。涉及到ByteBuffer的写操作，主要针对的方法就是<code>putXXXX()</code> 系列方法，下面将选取其核心的方法进行分析。 <br><br>首先通过一个例子来看在填充之后的各个索引值的情况</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token char">&#39;H&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token char">&#39;e&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token char">&#39;l&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token char">&#39;l&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token char">&#39;o&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+k+`" alt="image.png"><a name="pfEGE"></a></p><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> <br></h3><p>下面出源码的角度看看，可以看到,put之后，position索引值加1，符合上面的索引示意图</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 堆的HeapByteBuffer的实现</span>
<span class="token keyword">public</span> <span class="token class-name">ByteBuffer</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">byte</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    hb<span class="token punctuation">[</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">nextPutIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// 直接内存的DireactByteBuffer的实现</span>
<span class="token keyword">public</span> <span class="token class-name">ByteBuffer</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">byte</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    unsafe<span class="token punctuation">.</span><span class="token function">putByte</span><span class="token punctuation">(</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">nextPutIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><a name="MVNkn"></a>`,11),w=a('<p>_<strong>缓存区的翻转是一个非常重要的操作，可以简单的理解为从写模式切换到读模式的必须操作。</strong>_我们继续从上面的写入操作接着说，再写入Hello之后，其各个索引的状态为：<br></p><p><img src="'+d+'" alt="image.png"></p><p>那么重点来了，现在是写数据模式，当程序需要读数据的数据的时候 position 应当从当前值开始读吗？ limit的值应该是等于capacity 吗？ 很显然，既然读取数据，肯定是从头开始读取的，所以我们需要<strong>把position的值重置为0</strong>，切换为读模式了之后, limit的值标识的就是读的上限索引了，那么针对这样的情况，它就只能读到原先的写的位置了，所以需要把position的值赋值与limit。这就是flip() 翻转操作的底层实现了，经过翻转操作我们就可以从写模式切换到读模式.<br><br>经过写-&gt;读的模式切换后，其索引值被更新为<br><br></p><p><img src="'+f+`" alt="img.png"></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> <span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    limit <span class="token operator">=</span> position<span class="token punctuation">;</span>
    position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    mark <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><br><a name="62QRk"></a>`,7),x=a(`<p>相对于缓存区的翻转可以理解为写完之后需要读取数据，因此缓存区的释放可以理解为读完之后需要重新写入数据，从场景中也可以得知重新 <strong>写入position的值肯定是等于0，limit的值标识的就是写入的上限，也就是说limit=capacity</strong>，所以在释放之后其索引值更新如下<br></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   limit <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
   mark <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><br><img src="`+b+`" alt="image.png"><br>需要注意的是在释放之后，其实内存中的字节数据并没有真正的释放，其仍然在持有字节数据，在写入的时候则会不断的覆盖，从上图中也可以看出来，在clear() 操作之后，内存中仍然保存着之前的数据, <em><strong>在一些场景下可能就会造成内存泄漏</strong></em>。下面的程序可以验证:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token char">&#39;H&#39;</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token char">&#39;e&#39;</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token char">&#39;l&#39;</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token char">&#39;l&#39;</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token char">&#39;o&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 模拟清除数据</span>
    buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 尝试读取前4个字符 并断言</span>
    <span class="token keyword">assert</span> buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token char">&#39;H&#39;</span><span class="token punctuation">;</span>
    <span class="token keyword">assert</span> buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token char">&#39;e&#39;</span><span class="token punctuation">;</span>
    <span class="token keyword">assert</span> buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token char">&#39;l&#39;</span><span class="token punctuation">;</span>
    <span class="token keyword">assert</span> buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token char">&#39;l&#39;</span><span class="token punctuation">;</span>
    <span class="token keyword">assert</span> buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token char">&#39;o&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a name="IS2LL"></a></p><h3 id="缓存区的复制" tabindex="-1"><a class="header-anchor" href="#缓存区的复制" aria-hidden="true">#</a> 缓存区的复制</h3><br><br><p><a name="BjHPP"></a></p><h3 id="缓存区的其他操作" tabindex="-1"><a class="header-anchor" href="#缓存区的其他操作" aria-hidden="true">#</a> 缓存区的其他操作</h3><p>当然Buffer还提供了其操作API，比如 压缩 以及 重置标记等操作，其本质都是对 各个索引值进行操作，这一点从源码的角度也可以明确的看到，所以这里读者不在赘述，有兴趣的读者可以自行阅读这一部分的源码 <code>java.nio.HeapByteBuffer</code>。<br><br></p>`,11),j={href:"https://gitee.com/taoes_admin/architect/blob/master/network/src/main/java/com/zhoutao123/architect/buffer/BufferClearDemo.java",target:"_blank",rel:"noopener noreferrer"},I=n("br",null,null,-1);function H(P,N){const t=o("ExternalLinkIcon");return c(),i("div",null,[v,n("p",null,[y,h,s(" 是使用堆内存实现的ByteBuffer，因此在get的时候直接是从内部的char[] 数组中根据position索引获取的，在get()之后position的索引值会加一。同样的ByteBuffer还有一个直接内存的实现类 "),g,s(" , "),n("strong",null,[n("em",null,[s("这也是 Netty 框架实现零拷贝的一个核心类，在 "),n("a",B,[s("netty 源码分析的章节"),e(t)]),s(" 中会详细的阐述零拷贝的概念以及实现")])]),s("。")]),_,s(" ### 缓**存**区的翻转 "),w,s(" ### 缓存区的释放 "),x,n("blockquote",null,[n("p",null,[s("本文代码仓库位于 "),n("a",j,[s("https://gitee.com/taoes_admin/architect/blob/master/network/src/main/java/com/zhoutao123/architect/buffer/BufferClearDemo.java"),e(t)])])]),I])}const E=p(m,[["render",H],["__file","深入了解NIO核心类_ByteBuffer.html.vue"]]);export{E as default};
