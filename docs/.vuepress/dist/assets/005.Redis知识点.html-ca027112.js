import{_ as d,r,o as h,c as s,a as i,d as e,b as t,e as l}from"./app-d035ab8f.js";const o={},n=l('<h1 id="redis-知识点" tabindex="-1"><a class="header-anchor" href="#redis-知识点" aria-hidden="true">#</a> Redis 知识点</h1><h3 id="redis架构" tabindex="-1"><a class="header-anchor" href="#redis架构" aria-hidden="true">#</a> Redis架构</h3><ol><li>单线程、基于epoll实现的高效NoSQL数据库</li><li>全局HASH表</li></ol><h4 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h4><ol><li><p>单线程，内存性数据避免了上下文切换，因此特别快</p></li><li><p>基于Reactor 模型，底层使用epoll 方式实现</p></li><li><p>支持持久化，AOF，RDB 以及其混合模式</p></li><li><p>支持主从模式、高可用架构、分片架构</p></li><li><p>select, epoll 和 poll的区别:</p><ul><li>Select 是一种基于轮询的IO线程模型，需要遍历所有的连接channel，最大fd为1024</li><li>poll 可以看做是select的升级版本，可以自定义的监控fd不同的事件</li><li>epoll 是更加高级的操作，上述的两个方式都需要遍历所有的fd，而epoll只需要遍历有事件的fd，因此性能大大提升</li></ul></li></ol><h4 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h4><ol><li>缓存</li><li>分布式锁</li><li>共享Session</li><li>计数器</li><li>队列</li></ol><h3 id="redis的持久化" tabindex="-1"><a class="header-anchor" href="#redis的持久化" aria-hidden="true">#</a> Redis的持久化</h3><ul><li><p>AOF AOF文件重写 保存策略: 从不更新/每秒更新/每命令更新</p></li><li><p>RDB: Snapshot Redis Database 单位时间触发变动更新 BGSAVE/SVAE,特点是：不可读、数据量小、Fork 线程SAVE</p></li><li><p>Mixed: AOF &amp; RDB 混合模式, 性能较高，文件较小，但是不可读</p></li></ul><h2 id="redis对比" tabindex="-1"><a class="header-anchor" href="#redis对比" aria-hidden="true">#</a> Redis对比</h2><ol><li>Redis 支持持久化，分布式</li><li>Redis 单线程同步非阻塞  Memcache 多线程异步IO</li><li>Memcache 的KEY、VALUE 大小有限制，过期时间也有限制</li><li>Redis支持多种数据结构，Memcahe 支持一种</li></ol><h2 id="redis源码实现" tabindex="-1"><a class="header-anchor" href="#redis源码实现" aria-hidden="true">#</a> Redis源码实现</h2><ul><li>ZSET实现 压缩列表（ZipLists） 跳表(SkipLists)</li><li>String  SDS(数据结构预留一部分空间，类似于ArrrayList)embstr</li></ul><h2 id="redis数据类型" tabindex="-1"><a class="header-anchor" href="#redis数据类型" aria-hidden="true">#</a> Redis数据类型</h2><ul><li>字符串 String</li><li>哈希 Hash 类似MAP的数据结构</li><li>列表 List：可以实现栈，列表，阻塞队列等</li><li>无序不重复的集合Set: 自动化去重,交集,差集，并集等等</li><li>有序的集合Zset:权重，排行榜</li><li>Bitmap: 布隆过滤器</li><li>Geo : 地址位置 Geo</li><li>HyperLogLog: 基数统计</li></ul><h2 id="redis-事务" tabindex="-1"><a class="header-anchor" href="#redis-事务" aria-hidden="true">#</a> Redis 事务</h2><h3 id="特性" tabindex="-1"><a class="header-anchor" href="#特性" aria-hidden="true">#</a> 特性</h3><p>原子性，持久性，一致性，天然支持隔离性</p><h3 id="实现" tabindex="-1"><a class="header-anchor" href="#实现" aria-hidden="true">#</a> 实现</h3><p>MUTIL，EXEC，WARCH，DISCARD</p><h2 id="redis-应用" tabindex="-1"><a class="header-anchor" href="#redis-应用" aria-hidden="true">#</a> Redis 应用</h2><ol><li>Redis 订阅</li><li>Redis实现分布式锁</li><li>通道: 一次大批量执行命令，非原子性</li><li>Lua脚本支持</li></ol><h3 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h3><ol><li><p>缓存、DB 的数据一致性</p></li><li><p>缓存雪崩、缓存穿透、缓存击穿</p></li><li><p>Redis实现缓存</p></li><li><p>Redis 淘汰策略</p><ul><li>所有KEY最少使用、过期KEY中最少使用(LRU 算法)</li><li>所有KEY随机删除、过期KEY随机删除</li><li>回收过期KEY，按最小存活时间删除</li><li>返回错误信息，使客户端触发删除</li></ul></li><li><p>过期 KEY 删除方式</p></li></ol><ul><li>惰性删除，内存不友好</li><li>定期扫描(部分KEY，贪心算法) CPU不友好</li></ul><h2 id="redis-集群" tabindex="-1"><a class="header-anchor" href="#redis-集群" aria-hidden="true">#</a> Redis 集群</h2><h3 id="主从同步-读写分离" tabindex="-1"><a class="header-anchor" href="#主从同步-读写分离" aria-hidden="true">#</a> 主从同步 &amp; 读写分离</h3><p>其架构流程图</p><p><img src="https://api.zhoutao123.com/picture?param=yuque/0/2021/png/437981/1612499069810-4aead48d-9a42-4cba-bd94-01f39194ad43.png" alt=""></p><p>主服务器负责写数据，同步数据到从服务器；从服务器复制读数据，接收主服务的数据，执行</p><p><img src="https://api.zhoutao123.com/picture?param=yuque/__puml/7c432919de82f8df58d6ddc46c5337b1.svg" alt="https://api.zhoutao123.com/picture?param=yuque/__puml/7c432919de82f8df58d6ddc46c5337b1.svg"></p><h3 id="哨兵高可用模式" tabindex="-1"><a class="header-anchor" href="#哨兵高可用模式" aria-hidden="true">#</a> 哨兵高可用模式</h3><ol><li>客观下线与主观下线</li><li>选举模式 <ul><li>priority 低优先</li><li>Slaver数据多的有限</li><li>runid 低的优先</li></ul></li><li>哨兵之间的高可用： 一致性协议 Raft</li><li>故障转移：</li></ol>',33),c={href:"https://www.zhoutao123.com/page/book/mysql/category/tdu393?bookId=9",target:"_blank",rel:"noopener noreferrer"},p=l('<h3 id="分片集群模式" tabindex="-1"><a class="header-anchor" href="#分片集群模式" aria-hidden="true">#</a> 分片集群模式</h3><ol><li>通过Hash确定Slot插槽</li><li>拓展不易需要重新计算插槽</li></ol><h3 id="redis-优化操作" tabindex="-1"><a class="header-anchor" href="#redis-优化操作" aria-hidden="true">#</a> Redis 优化操作</h3><ul><li>尽量使用短的key</li><li>避免使用keys *</li><li>在存到Redis之前先把你的数据压缩下</li><li>设置 key 有效期</li><li>选择回收策略(maxmemory-policy)</li><li>使用bit位级别操作和byte字节级别操作来减少不必要的内存使用。</li><li>尽可能地使用hashes哈希存储。</li><li>当业务场景不需要数据持久化时，关闭所有的持久化方式可以获得最佳的性能。</li><li>想要一次添加多条数据的时候可以使用管道。</li><li>限制redis的内存大小（64位系统不限制内存，32位系统默认最多使用3GB内存）</li></ul>',4);function u(f,b){const a=r("ExternalLinkIcon");return h(),s("div",null,[n,i("blockquote",null,[i("p",null,[e("参考文章 ： "),i("a",c,[e("Redis 的三种集群模式"),t(a)])])]),p])}const R=d(o,[["render",u],["__file","005.Redis知识点.html.vue"]]);export{R as default};
