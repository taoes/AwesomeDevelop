import{_ as a,r as o,o as t,c as n,a as l,d as i,b as r,e as c}from"./app-d035ab8f.js";const u={},p=l("h1",{id:"java-并发编程知识点",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#java-并发编程知识点","aria-hidden":"true"},"#"),i(" Java 并发编程知识点")],-1),s={href:"https://www.zhoutao123.com/page/book/11",target:"_blank",rel:"noopener noreferrer"},h=c("<ul><li><p>Java 内存模型基础</p></li><li><p>第1章 并发编程的挑战</p><ul><li>上下文切换</li><li>死锁的检测以及示例代码</li></ul></li><li><p>第2章 Java 并发编程的底层实现原理</p><ul><li>Java并发编程的底层实</li><li>Volatile的应用和实现</li></ul></li><li><p>第3章 Java 的内存模型</p><ul><li>重排序-指令重排</li><li>Happens-Before 原则</li><li>顺序一致性与其内存模型</li><li>final 域的内存语义</li><li>volatile 的内存语义</li><li>Lock的内存语义</li><li>双重检查与延迟初始化</li></ul></li><li><p>第4章 Java 并发编程基础</p><ul><li>进程 VS 线程 ?</li><li>线程状态以及守护线程</li><li>线程创建 &amp; 线程优先级</li><li>线程的启动和终止</li><li>线程之间的通讯机制详解</li><li>多线程的应用-异步任务线程池的简单实现</li><li>多线程的应用-简单实现数据库连接池</li></ul></li><li><p>第5章 Java 中锁的应用以及原理</p><ul><li>Lock 与 队列同步器 AbstractQueueSynchronizer</li><li>AbstractQueueSynchronizer 独占式超时获取同步状态</li><li>AbstractQueueSynchronizer 独占式同步状态的获取与释放原理</li><li>AbstractQueueSynchronizer 共享式同步状态获取与释放原理</li><li>可重入锁 ReentrantLock 使用与实现原理</li><li>Condition 的使用范式以及原理</li><li>读写锁的使用与实现远离 &amp; LockSupport 工具</li></ul></li><li><p>第6章 并发编程容器和框架</p><ul><li>并发编程容器与框架</li><li>Frok/Join示例与原理</li></ul></li><li><p>第7章 原子化操作</p><ul><li>原子更新与Unsafe操作</li><li>原子化更新操作使用案例以及实现原理</li></ul></li><li><p>第8章 并发编程工具类</p><ul><li>等待多线程完成 CountDownLatch</li><li>同步屏障 CyclicBarrier</li><li>控制线程并发数 Semaphore</li><li>线程间交换数据 Exchanger</li></ul></li><li><p>第9章 Java 线程池和 Executor 框架</p></li></ul>",1);function _(d,v){const e=o("ExternalLinkIcon");return t(),n("div",null,[p,l("blockquote",null,[l("p",null,[i("正在完善中，麻烦跳转到本人博客网站浏览 "),l("a",s,[i("燕归来兮-Java并发编程学习笔记"),r(e)])])]),h])}const k=a(u,[["render",_],["__file","index.html.vue"]]);export{k as default};
