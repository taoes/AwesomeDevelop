import{_ as i,o as a,c as l,e}from"./app-d035ab8f.js";const h={},r=e('<h1 id="mysql-知识点" tabindex="-1"><a class="header-anchor" href="#mysql-知识点" aria-hidden="true">#</a> MySQL 知识点</h1><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h2><h4 id="acid-特性" tabindex="-1"><a class="header-anchor" href="#acid-特性" aria-hidden="true">#</a> ACID 特性</h4><ul><li>原子性： 要么全部成功，要么全部失败</li><li>一致性： 事务只能从一种一致性状态转换到另外一种一致性状态</li><li>持久性： 事务一旦提交之后，就会持久化到磁盘介质上</li><li>隔离性： 事务与事务之间具有隔离的特性</li></ul><h3 id="隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离级别" aria-hidden="true">#</a> 隔离级别</h3><ul><li>读未提交: 无法解决 脏读、不可重复度以及幻读</li><li>读已提交： 无法解决脏读 &amp;不可重复度【Oracle默认】</li><li>可重复读： 无法解决脏读【MYSQL默认】</li><li>串行化：解决所有问题，但性能较低</li></ul><blockquote><p>隔离级别实现方式: 读写锁 + MVCC</p></blockquote><h4 id="innodb-实现-mvcc的方式" tabindex="-1"><a class="header-anchor" href="#innodb-实现-mvcc的方式" aria-hidden="true">#</a> Innodb 实现 MVCC的方式</h4><ol><li>每行记录都有一个版本号</li><li>InnoDB通过X锁的方式锁定行</li><li>将元数据拷贝到Undo Log，通过引用的方式指向undolog 中的元数据</li><li>修改行记录版本号</li></ol><h3 id="acid-特性实现原理" tabindex="-1"><a class="header-anchor" href="#acid-特性实现原理" aria-hidden="true">#</a> ACID 特性实现原理</h3><ol><li>原子性由 undo log 保证，记录了未被修改的数据，当回滚的时候，使用undo log 实现回滚</li><li>一致性 一般由代码层实现</li><li>隔离性有版本号实现，即MVCC （Multi Version Concurrent  Controller 多版本并发控制）</li><li>持久性由 内存 + redolog 实现  事务提交时候通过redo log 刷盘，宕机时候通过 redo log 恢复数据</li></ol><h2 id="存储引擎" tabindex="-1"><a class="header-anchor" href="#存储引擎" aria-hidden="true">#</a> 存储引擎</h2><h3 id="innodb" tabindex="-1"><a class="header-anchor" href="#innodb" aria-hidden="true">#</a> InnoDB</h3><p>InnoDB 存储引擎支持外键、聚簇索引、事务、行级锁、表级锁. 插入缓存、二次写、自适应Hash索引 以及预读. 在锁机制中锁机制支持:</p><ul><li>共享锁（S锁）即读取的时候不能修改，实现方式 LOCK IN SHARE MODE；</li><li>同时也支持排它锁(X) 写的时候不能读也不能写，实行方式 版本号(乐观锁) 或者 FOR UPDATE(悲观锁);</li><li>间隙锁 （Gap Lock）未解决幻读的一种方式</li><li>锁的算法:  Record Key、Gap Key &amp; Next-Key Lock</li><li>锁的特点: 行级锁:占用更多的内存，在表大量使用的时候，因为要获取指定的行锁，所以速度较慢仅仅锁定部分数据、可以长时间的锁定某一行</li></ul><h3 id="innodb的索引" tabindex="-1"><a class="header-anchor" href="#innodb的索引" aria-hidden="true">#</a> InnoDB的索引</h3><p>采用自增ID作为PK,每个数据表都有一个默认的PK,索引被记录在B+树上，如果使用整型作为主键会自动的插入后续问题之,如果不使用自增主键，则插入的数据可能会乱，造成大量的不连续的空间，造成表文件很大</p><h4 id="btree索引和hash索引" tabindex="-1"><a class="header-anchor" href="#btree索引和hash索引" aria-hidden="true">#</a> BTREE索引和HASH索引</h4><ol><li>BTREE索引更好地减少查询次数和IO次数，通过变种的BTREE索引更好地支持范围查找</li><li>HASH索引比BTREE更快，但应用场景有限，不支持最左匹配，仅支持 等于 IN 等操作</li><li>BTREE索引会适当的冗余数据并且完整的保存了整条数据，通过ID查询不会再次的进行回表操作</li><li>HASH 等值查询的效率较低，尤其是出现大量冲突的情况,在InnoDB的监控预测下，如果发现Hash索引效率更高，则会默认转换为Hash索引</li></ol><h4 id="不适合创建索引的情况" tabindex="-1"><a class="header-anchor" href="#不适合创建索引的情况" aria-hidden="true">#</a> 不适合创建索引的情况</h4><ol><li>数据量少</li><li>大量写少量读的情况</li><li>大量重复数据的列</li></ol><h3 id="innodb的日志" tabindex="-1"><a class="header-anchor" href="#innodb的日志" aria-hidden="true">#</a> InnoDB的日志</h3><p>误日志，查询日志，慢查询日志，binlog日志以及中继日志,undo log  &amp; redo log</p><h3 id="myisam-索引" tabindex="-1"><a class="header-anchor" href="#myisam-索引" aria-hidden="true">#</a> MyISAM 索引</h3><ul><li>不支持聚簇索引，索引文件 MYI 和 数据文件 MYD 不再同一个文件中，因此不支持聚簇索引</li><li>仅支持表级锁，不支持行级锁 、 不支持外键</li></ul><h3 id="memory-索引" tabindex="-1"><a class="header-anchor" href="#memory-索引" aria-hidden="true">#</a> Memory 索引</h3><p>内存型存储引擎，重启后丢失数据，适合临时计算的保存</p><h2 id="sql语句种类" tabindex="-1"><a class="header-anchor" href="#sql语句种类" aria-hidden="true">#</a> SQL语句种类</h2><ul><li>DDL 数据库定义语言</li><li>DML 数据库操作语言</li><li>DCL 数据库控制语言</li><li>TCL 事务控制语言</li></ul><h2 id="mysql性能优化" tabindex="-1"><a class="header-anchor" href="#mysql性能优化" aria-hidden="true">#</a> MySQL性能优化</h2><h3 id="分表" tabindex="-1"><a class="header-anchor" href="#分表" aria-hidden="true">#</a> 分表</h3><ul><li>垂直分表: 一个表中热点数据和非热点数据进行拆分</li><li>水平分表: 通过将某个字段自动hash的方式实现水评分表</li></ul><blockquote><p>水平分表的ID方案: 设置不同步长的自增，分布式ID服务 &amp; 自增雪花算法生成</p></blockquote><h3 id="分库" tabindex="-1"><a class="header-anchor" href="#分库" aria-hidden="true">#</a> 分库:</h3><p>MyCAT 等中间件实现分库</p><h3 id="主从同步" tabindex="-1"><a class="header-anchor" href="#主从同步" aria-hidden="true">#</a> 主从同步</h3><p>同步方式基于 bin log实现， BinLog的日志格式分为： Statement、RAW 以及 Mixed</p><ul><li>RAW: 记录变动记录，不会造成数据不一致的问题,数据量较大，尤其是ALTER或者批量修改的时候</li><li>Statement: 记录SQL语句,简单, 数据量小,无法处理 CURRENT_DATE() /RAND() 造成数据不一致的问题</li><li>Mixed： 即Statemtn + RAW 的混合模式，一般语句使用Statement记录，对于一些函数使用RAW记录</li></ul><h3 id="主从同步的方式" tabindex="-1"><a class="header-anchor" href="#主从同步的方式" aria-hidden="true">#</a> 主从同步的方式</h3><ul><li>全同步复制(类似于ZK的CP的方式，所有从服务器成功后再返回客户端)</li><li>半同步复制(主服务器接收到至少一个从服务器的ACK确认后任务成功)</li></ul><h3 id="架构原因以及问题" tabindex="-1"><a class="header-anchor" href="#架构原因以及问题" aria-hidden="true">#</a> 架构原因以及问题</h3><ul><li>主从同步的原因是分担读压力</li><li>主从同步的问题: 数据一致性问题（最终一致性）</li></ul><h3 id="同步过程" tabindex="-1"><a class="header-anchor" href="#同步过程" aria-hidden="true">#</a> 同步过程</h3><ol><li>Master 将已提交的事务记录写入binlog</li><li>Slaver 配置主服务器，拉取binlog</li><li>Master 创建dump线程，将binlog 推给slave</li><li>Slaver创建IO线程，读取同步过来的reply log</li><li>salver 开启新的线程处理 reply log</li><li>salver 记录自己的 binlog 日志</li></ol><h3 id="慢查询的优化方式" tabindex="-1"><a class="header-anchor" href="#慢查询的优化方式" aria-hidden="true">#</a> 慢查询的优化方式</h3><ul><li>限制范围查询，比如6个月内</li><li>主从同步、读写分离</li><li>上级拦截，缓存机制</li><li>垂直分表/水平分表</li><li>执行计划</li><li>索引SQL优化</li></ul>',46),d=[r];function n(o,t){return a(),l("div",null,d)}const s=i(h,[["render",n],["__file","004.MySQL知识点.html.vue"]]);export{s as default};
