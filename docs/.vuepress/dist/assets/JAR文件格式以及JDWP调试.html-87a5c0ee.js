import{_ as t,r as i,o,c as p,a as n,d as s,b as l,e as a}from"./app-d035ab8f.js";const c="/assets/jdwp调试_idea-7ef8187a.png",r="/assets/jdwp调试_debug-449ede81.png",d={},u=a(`<h1 id="jar文件格式以及jdwp调试" tabindex="-1"><a class="header-anchor" href="#jar文件格式以及jdwp调试" aria-hidden="true">#</a> JAR文件格式以及JDWP调试</h1><h2 id="jar文件是如何启动的" tabindex="-1"><a class="header-anchor" href="#jar文件是如何启动的" aria-hidden="true">#</a> JAR文件是如何启动的？</h2><p>SpringBoot构建的结果中，尝尝会以JAR文件的形式提供，众所周知，JAR文件本质上是一个特殊的压缩文件，这里我们创建一个简单的SpringBoot项目，使用Maven 或者Gradle 构建，然后解压，其内容格式如下:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>├── BOOT-INF
│   ├── classes
│   │   ├── application.properties
│   │   ├── com
│   │   ├── static
│   │   └── templates
│   └── lib
│       ├── classmate-1.5.1.jar
|       |—— 这里由于篇幅忽略一写第三方的依赖JAR
│       └── tomcat-embed-websocket-9.0.33.jar
├── META-INF
│   └── MANIFEST.MF
└── org
    └── springframework
        └── boot

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以很明显的看到，JAR中包含了第三方的JAR包，这显然使用默认的应用类加载器是无法加载编译生成的class的以及我们生成的目录classes中的的class文件的。</p><p>尝试查看 MAINFEST.MF 文件，其内容如下:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">cat</span> ./build/libs/springboot-0.0.1-SNAPSHOT/META-INF/MANIFEST.MF 
Manifest-Version: <span class="token number">1.0</span>
Start-Class: com.zhoutao123.spring.springboot.SpringbootApplication
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Spring-Boot-Version: <span class="token number">2.2</span>.6.RELEASE
Main-Class: org.springframework.boot.loader.JarLauncher

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7),v={href:"https://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html#Signed%20JAR%20File",target:"_blank",rel:"noopener noreferrer"},g=a(`<p>Main-Class 指定了JVM 在运行JAR文件的是时候，所启动的类，这个类必须包含一个共有的静态的main方法，<strong>这也是为什么SpringBoot的在打包的时候，会将org.springframework.boot.loader 的包给放到最外层，这样,其启动类 <strong><strong><code>Launcher.class</code></strong></strong> 就可以正常的被加载到系统类加载器</strong>, **在其他位置的加载器中，系统类加载器无法加载的JAR文件或者BOOT-INFO/classes 文件下的 class文件，则使用自定义的类加载器加载。**可以通过下面的代码验证，SpringBoot APP的启动类并不是系统类加载器加载，而是自定义的类加载器加载的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringbootApplication</span> <span class="token punctuation">{</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;当前类的加载器为:&quot;</span> <span class="token operator">+</span> <span class="token class-name">SpringbootApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">SpringbootApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请不要尝试在IDE中尝试验证</strong>，如果在IDE中运行的话，你可能得到的结果如下，这里因为在集成开发环境中运行，class文件是松散的保存在classPath目录中的，这时候并没有启动自定义的加载类，因为仍然是默认的系统类加载器加载。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>当前类的加载器为:sun.misc.Launcher$AppClassLoader@18b4aac2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>构建成新的JAR文件之后，使用 <code>java -jar xxxx.jar</code> 命令启动后，可以看到输出为</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>当前类的加载器为:org.springframework.boot.loader.LaunchedURLClassLoader@5197848c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>[x]  可以看到，系统类加载器为 <code>org.springframework.boot.loader.LaunchedURLClassLoader</code> 这就是我们将要深入学习的SpringBoot的自定义类加载器。</li></ul><h2 id="使用jdwp来远程调试" tabindex="-1"><a class="header-anchor" href="#使用jdwp来远程调试" aria-hidden="true">#</a> 使用JDWP来远程调试</h2><p>上面的JAR文件的类加载器是JVM启动的才会调用，在IDE中调试并不是使用SpringBoot的自定义类加载器加载，因此我们这里需要使用JDK的远程调试功能来调试代码。 在命令行输入如下格式的语法命令，来启动JAR，这里不再对JDWP过多的赘述，有兴趣的可以在网上查一下。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">java</span> <span class="token parameter variable">-agentlib:jdwp</span><span class="token operator">=</span>transport<span class="token operator">=</span>dt_socket, <span class="token punctuation">\\</span>
              <span class="token assign-left variable">server</span><span class="token operator">=</span>y,suspend<span class="token operator">=</span>y,address<span class="token operator">=</span><span class="token number">9999</span> <span class="token punctuation">\\</span>
              <span class="token parameter variable">-jar</span> xxxx.jar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，在IDEA中，创建远程调试，信息如下:</p><p><img src="`+c+`" alt="image.png"></p><p>然后在Gradle依赖中添加 SpringBootLoader的依赖</p><div class="language-groovy line-numbers-mode" data-ext="groovy"><pre class="language-groovy"><code>implementation <span class="token string">&#39;org.springframework.boot:spring-boot-loader&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者Maven的pom文件中添加</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-loader<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>找到  JarLauncher 类添加断点，然后以Degbug模式启动在IDEA创建的远程调试，即可看到正确进入断点。 <img src="`+r+'" alt="image.png"></p>',17);function m(k,b){const e=i("ExternalLinkIcon");return o(),p("div",null,[u,n("ul",null,[n("li",null,[s("MAINFEST.MF 文件的格式内容，可以参考: "),n("a",v,[s("JAR 文件格式规范"),l(e)])])]),g])}const x=t(d,[["render",m],["__file","JAR文件格式以及JDWP调试.html.vue"]]);export{x as default};
