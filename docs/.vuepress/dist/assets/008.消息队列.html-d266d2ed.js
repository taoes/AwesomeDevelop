import{_ as a,o as e,c as i,e as r}from"./app-d035ab8f.js";const d={},l=r('<h3 id="_1-消息队列的使用场景" tabindex="-1"><a class="header-anchor" href="#_1-消息队列的使用场景" aria-hidden="true">#</a> 1. 消息队列的使用场景</h3><p>消息队列主要是为了解决应用耦合，异步消息，流量削峰等问题，实现高性能，高可用，可伸缩和最终一致性架构。消息队列：ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。</p><h3 id="_2-消息的重发-补充策略" tabindex="-1"><a class="header-anchor" href="#_2-消息的重发-补充策略" aria-hidden="true">#</a> 2. 消息的重发，补充策略</h3><p>在MQ中，当消费者消费消息产生异常时, 消费者会把消息放入一个特殊队列中, 进行下次处理，这就是消息的重发</p><h3 id="_3-如何保证消息的有序性" tabindex="-1"><a class="header-anchor" href="#_3-如何保证消息的有序性" aria-hidden="true">#</a> 3. 如何保证消息的有序性</h3><p>消息队列的底层数据实现便是队列，先进先出，便保证了消息的有序性</p><h3 id="_4-用过哪些mq-和其他mq比较有什么优缺点" tabindex="-1"><a class="header-anchor" href="#_4-用过哪些mq-和其他mq比较有什么优缺点" aria-hidden="true">#</a> 4. 用过哪些MQ，和其他mq比较有什么优缺点</h3><p>ActiveMQ，RabbitMQ,Kafka,RocketMQ,ZeroMQ</p><ul><li>RabbitMQ：采用Erlang语言实现的AMQP协议的消息中间件。优点，可靠性，可用性，扩展性，功能丰富。</li><li>Kafka：一个分布式/多分区/多副本基于zookeeper协调的分布式消息系统、高吞吐量的分布式发布订阅消息系统。</li></ul><h3 id="_5-mq系统的数据如何保证不丢失" tabindex="-1"><a class="header-anchor" href="#_5-mq系统的数据如何保证不丢失" aria-hidden="true">#</a> 5. MQ系统的数据如何保证不丢失</h3><p>1.消息持久化</p><ul><li>Exchange 设置持久化</li><li>Queue设置持久化</li><li>Message持久化发送，发送消息设置发送模式deliveryMode=2，代表持久化消息</li></ul><ol start="2"><li><p>ACK确认机制</p><p>消费端消费完成时需要通知服务端，服务端才把消息从内存中删除</p></li><li><p>设置集群镜像模式</p></li></ol><h3 id="_6-rabbitmq-实现高可用" tabindex="-1"><a class="header-anchor" href="#_6-rabbitmq-实现高可用" aria-hidden="true">#</a> 6. RabbitMQ 实现高可用</h3><p>RabbitMQ分为3种模式 单一模式（非集群模式）、普通模式（默认的集群模式）、镜像模式</p><h3 id="_7、kafka吞吐量高的原因" tabindex="-1"><a class="header-anchor" href="#_7、kafka吞吐量高的原因" aria-hidden="true">#</a> 7、kafka吞吐量高的原因</h3><ol><li>顺序读写</li><li>零拷贝</li><li>分区</li><li>批量发送</li><li>数据压缩</li></ol><h3 id="kafka-和其他消息队列的区别-kafka-主从同步怎么实现" tabindex="-1"><a class="header-anchor" href="#kafka-和其他消息队列的区别-kafka-主从同步怎么实现" aria-hidden="true">#</a> kafka 和其他消息队列的区别，kafka 主从同步怎么实现</h3><ul><li>高性能跨语言分布式发布/订阅消息队列系统</li><li>快速持久化，可以在O(1)的系统开销下进行消息持久化；</li><li>高吞吐，在一台普通的服务器上既可以达到10W/s的吞吐速率；</li><li>完全的分布式系统，Broker、Producer、Consumer都原生自动支持分布式，自动实现负载均衡；</li><li>支持Hadoop数据并行加载，对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理。</li><li>一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。</li></ul><h3 id="_9、mq有可能发生重复消费-如何避免-如何做到幂等" tabindex="-1"><a class="header-anchor" href="#_9、mq有可能发生重复消费-如何避免-如何做到幂等" aria-hidden="true">#</a> 9、MQ有可能发生重复消费，如何避免，如何做到幂等</h3><p>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</p><p>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</p><p>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据</p>',23),h=[l];function t(o,n){return e(),i("div",null,h)}const s=a(d,[["render",t],["__file","008.消息队列.html.vue"]]);export{s as default};
