import{_ as r,r as l,o as s,c as n,a as e,d as i,b as t,e as o}from"./app-d035ab8f.js";const c="/assets/bubble_img-33e6d21c.png",h="/assets/select_img-fae8dbcc.png",d="/assets/insert_img-a0016845.png",_="/assets/shell_img-4e61fb45.png",m="/assets/merge_img-e4016282.png",p="/assets/merge_sort_o-d22f38f6.png",u="/assets/quickSort-cdeb9432.png",g={},f=e("p",null,"本仓库仅仅记录理论知识，排序算法的实现参考其他仓库的代码",-1),b={href:"https://github.com/taoes/architect/blob/master/struct/src/main/java/com/zhoutao123/sort/AnExampleOfJavaSort.java",target:"_blank",rel:"noopener noreferrer"},x={href:"https://gitee.com/taoes_admin/architect/blob/master/struct/src/main/java/com/zhoutao123/sort/AnExampleOfJavaSort.java",target:"_blank",rel:"noopener noreferrer"},v=o('<h2 id="简单排序算法" tabindex="-1"><a class="header-anchor" href="#简单排序算法" aria-hidden="true">#</a> 简单排序算法</h2><h4 id="冒泡排序法" tabindex="-1"><a class="header-anchor" href="#冒泡排序法" aria-hidden="true">#</a> 冒泡排序法</h4><ul><li>核心思想: 将第i个数字和第i+1个数字比较，如果比之大，那么则交换，每一次遍历完成后，最后一个为最大数</li><li>时间复杂度: O(n^2)</li></ul><p><img src="'+c+'" alt="冒泡排序法"></p><h4 id="选择排序法" tabindex="-1"><a class="header-anchor" href="#选择排序法" aria-hidden="true">#</a> 选择排序法</h4><ul><li>核心算法： 从中选出最小的数据，放在头部相应的位置，然后从剩下的部分中在选出最小的数据，依次类推，完成排序</li><li>时间复杂度: O(n^2)</li></ul><p><img src="'+h+'" alt="img.png"></p><h4 id="插入排序" tabindex="-1"><a class="header-anchor" href="#插入排序" aria-hidden="true">#</a> 插入排序</h4><ul><li>核心算法: 假定前面的是有序的，拿到新的数据后依次向左插入，直到遇到比他小的数据后停止，然后继续插入下个数据</li><li>时间复杂度: O(n^2)</li></ul><p><img src="'+d+'" alt="img.png"></p><h2 id="高级排序算法" tabindex="-1"><a class="header-anchor" href="#高级排序算法" aria-hidden="true">#</a> 高级排序算法</h2><h4 id="希尔排序" tabindex="-1"><a class="header-anchor" href="#希尔排序" aria-hidden="true">#</a> 希尔排序</h4><ul><li>核心算法: 分组-插入排序</li><li>时间复杂度: O(n^(1.3-2))</li></ul><p><img src="'+_+'" alt="img.png"></p><h4 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序" aria-hidden="true">#</a> 归并排序</h4><ul><li>核心算法: 分治算法</li><li>时间复杂度: O(n * lgn)</li></ul><p><img src="'+m+'" alt="img.png"></p><ul><li>时间复杂度计算</li></ul><p><img src="'+p+'" alt="img.png"></p><h4 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序" aria-hidden="true">#</a> 快速排序</h4><ol><li>选择首元素作为基准元素，然后小于基准元素的放在组边，大于基准元素的放在右边</li><li>对基准元素左右两侧的数据重复步骤1 <img src="'+u+'" alt="img.png"></li></ol><h4 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序" aria-hidden="true">#</a> 堆排序</h4><ul><li>核心算法: 是对插入排序的优化，优化了查找最大数的方式，通过构建最大堆的方式在堆的订单找到最大值，然后和最后一位交换</li><li>时间复杂度: O(n * lgn)</li></ul>',23);function k(O,E){const a=l("ExternalLinkIcon");return s(),n("div",null,[e("blockquote",null,[f,e("ul",null,[e("li",null,[e("a",b,[i("Github 仓库"),t(a)])]),e("li",null,[e("a",x,[i("Gitee 仓库"),t(a)])])])]),v])}const N=r(g,[["render",k],["__file","015.排序算法.html.vue"]]);export{N as default};
