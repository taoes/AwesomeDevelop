import{_ as s,o as n,c as a,e}from"./app-d035ab8f.js";const i={},l=e(`<h1 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h1><p>全局哈希表，NIO，epoll_wait（timeout） 超时模型</p><h1 id="redis的数据结构与对象" tabindex="-1"><a class="header-anchor" href="#redis的数据结构与对象" aria-hidden="true">#</a> Redis的数据结构与对象</h1><h2 id="sds" tabindex="-1"><a class="header-anchor" href="#sds" aria-hidden="true">#</a> SDS</h2><ul><li><p>Redis 并没有直接使用C语言的字符串格式(即 &#39;\\0&#39; 的风格) 而是自己构建可一个名为简单动态字符串的抽象类型，需要注意的是，SDS 仅仅在KV中被使用，在代码的日志等常量字符串中依旧使用的是字符串字面量</p><p>比如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>redis<span class="token operator">&gt;</span> SET msg <span class="token string">&quot;hello, world&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在Redis 的底层中 msg 也是一个SDS，&quot;hello, world&quot; 也是一个SDS</p></li><li><p>SDS 的数据结构如下</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">sdshdr</span><span class="token punctuation">{</span>
  <span class="token comment">// 记录buf中已使用的字节的数量</span>
  <span class="token keyword">int</span> len<span class="token punctuation">;</span>
  
  <span class="token comment">// 记录buf中未使用的字节的数量</span>
  <span class="token keyword">int</span> free<span class="token punctuation">;</span>
  
  <span class="token comment">// 字节数组用于保存字符串, buf的最后一位仍然是 &#39;\\0&#39;</span>
  <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>除了用于保存数据库中的字符串之外，SDS还被用于缓冲区(buffer) 以及AOF模块中的缓冲区</p></li><li><p>SDS 中的buf的结尾处依然遵循C语言的传统，其尾部是 &#39;\\0&#39; 这样做的好处是可以直接复用 C 语言的相关函数，而无需为SDS编写专门的函数，比如</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s&quot;</span><span class="token punctuation">,</span>s<span class="token operator">-&gt;</span>buf<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>C 语言的字符串并不适用于Redis的原因:</p><blockquote><ol><li>C 字符串并不保存字符串的长度信息，获取其长度的时间复杂度为O(n) 而SDS的时间复杂度则为O(1)</li><li>除了获取字符串长度的时间复杂度高之外，C语言字符串容易带来缓冲区溢出的风险，比如在合并字符串 strcat 之前需要确保字符串的空间足够，否则就会出现缓冲区溢出的问题，但SDS则不会出现这个问题，当SDS不满足空间大小要求的时间，其会自动拓展至所需要的空间大小，然后才执行操作</li><li>减少修改字符串时带来的内存重分配问题，如果执行的C字符串增长操作，则必须先通过内存重分配来手动拓展空间，否则会出现缓冲区溢出的风险；如果执行的是缩短操作，那么进行内存重分配缩短空间，否则可能会出现内存泄漏的问题，而每次执行内存重分配则是一个非常耗时的操作。且频繁的进行内存重分配对于速度要求苛刻的Redis来说显然是不合适。</li><li>二进制安全性, 在使用Redis存储二进制数据的时候，不能强制要求使用 &#39;\\0&#39; 作为结束符号，常见的文件，图片以及音频视频等等就不能，通过二进制安全，使得Redis的SDS可以保存二进制数据</li></ol></blockquote></li></ul><h2 id="链表" tabindex="-1"><a class="header-anchor" href="#链表" aria-hidden="true">#</a> 链表</h2><ul><li></li></ul>`,7),t=[l];function d(c,o){return n(),a("div",null,t)}const r=s(i,[["render",d],["__file","001.Redis的数据结构与对象.html.vue"]]);export{r as default};
