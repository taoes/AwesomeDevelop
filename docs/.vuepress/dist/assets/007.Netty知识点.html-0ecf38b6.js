import{_ as a,o as e,c as n,e as s}from"./app-d035ab8f.js";const t={},c=s(`<h2 id="java-nio" tabindex="-1"><a class="header-anchor" href="#java-nio" aria-hidden="true">#</a> Java NIO</h2><p>使用 strace 命令追踪应用与Linux内核交互的代码逻辑,这里以BIO代码为示例</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>stracr <span class="token parameter variable">-ff</span> <span class="token parameter variable">-o</span> out <span class="token punctuation">[</span>command<span class="token punctuation">]</span> <span class="token punctuation">[</span>args<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>NIO 优势: 避免多线程的问题，C10K</li><li>NIO 劣势: 仍然是同步的线程模型，因为仍然需要程序自己去读IO，因此是同步的IO模型，</li></ul><h3 id="多路复用器的实现" tabindex="-1"><a class="header-anchor" href="#多路复用器的实现" aria-hidden="true">#</a> 多路复用器的实现</h3><p>多路复用器是内核实现的功能。 多路复用器只能提供链接的状态，具体读取数据还是由程序去读。</p><h3 id="select、poll-优劣势" tabindex="-1"><a class="header-anchor" href="#select、poll-优劣势" aria-hidden="true">#</a> select、poll 优劣势</h3><ul><li>通过一次系统调用由内核进行遍历，减少了系统调用的次数</li><li>每次调用系统方法，都会造成大量的fd重复传递(内核开辟空间，保存fd)</li><li>每次select，poll 都需要重新遍历所有的连接</li></ul><h3 id="epoll-详解" tabindex="-1"><a class="header-anchor" href="#epoll-详解" aria-hidden="true">#</a> epoll 详解</h3><p>epoll的常用三个方法<code>epoll_create</code> , <code>epoll_ctl</code> 以及<code>epoll_wait</code>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 实际上会调用 epoll_create() 方法</span>
<span class="token class-name">Service</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span><span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_ACCEPT</span><span class="token punctuation">)</span> <span class="token comment">//实际上会调用 epoll_ctl</span>
selector<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 实际上会调用 epoll_wait() 方法</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="netty的线程模型" tabindex="-1"><a class="header-anchor" href="#netty的线程模型" aria-hidden="true">#</a> netty的线程模型</h2><ul><li>reactor单线程模型 用户发起io操作到事件分离器。事件分离器调用相应的处理器处理事件，事件处理完之后，事件分离器获得控制权，继续相应处理</li><li>reactor多线程模型 单线程中，每个io事件都在同一个线程中执行，当其中一个io出现异常时，将导致后面的io处理不了， 在多线程中，事件分离器中有reactorThreadacceptor和reactorThreadPool。reactorThreadacceptor接收到一个io事件，将io事件交于线程池处理，自己继续等待其他io事件。</li><li>reactor主从多线程模型。 Acceptor不再是一个线程，而是一个nio线程池。acceptor仅仅完成登录，握手，认证等，其他业务扔交给work线程池 NioEventLoop 1.作为服务端Acceptor线程，负责处理客户端的请求接入 2.作为客户端Connecor线程，负责注册监听连接操作位，用于判断异步连接结果 3.作为IO线程，监听网络读操作位，负责从SocketChannel中读取报文 4.作为IO线程，负责向SocketChannel写入报文发送给对方，如果发生写半包，会自动注册监听写事件，用于后续继续发送半包数据，直到数据全部发送完成</li></ul><h3 id="netty优势" tabindex="-1"><a class="header-anchor" href="#netty优势" aria-hidden="true">#</a> Netty优势</h3><p>使用io，性能跟不上，使用原生nio，复杂的API并不方便使用，搭建一套优秀的nio框架并不容易。使用现成的netty，节省开发时间，提高系统性能。</p><h3 id="什么是tcp粘包-拆包" tabindex="-1"><a class="header-anchor" href="#什么是tcp粘包-拆包" aria-hidden="true">#</a> 什么是TCP粘包/拆包</h3><p>客服端发送了两个数据包，服务器端只收到了一个数据包。tcp协议不会出现丢包，说明两个数据包被粘在一起了，即为粘包。 客服端发送一个数据包，服务器端收到了两个数据包，即为拆包。 原因（为什么要粘包和拆包） 1.应用程序写入的数据大于套接字缓冲区大小，需要拆包 2.写入的数据小于套接字缓冲区大小，网卡将多次写入的数据发送到网络，发生粘包 3.接收方法不及时读取套接字缓冲区数据，发生粘包。</p><ul><li>解决方式</li></ul><p>1.发送端给每个数据包添加包首部。首部中应该包含数据包的长度，这样在接受端通过读取包首部，便能准确地读到有用的数据 2.发送端将数据包封装为固定长度，不够补齐0，接受端再读取固定长度的数据，便能准确将粘包的数据进行拆包。 3.在数据包设置边界，添加特殊字符，这样便能够通过特殊字符进行拆分。</p><h3 id="netty的心跳处理在弱网下怎么办" tabindex="-1"><a class="header-anchor" href="#netty的心跳处理在弱网下怎么办" aria-hidden="true">#</a> netty的心跳处理在弱网下怎么办</h3><p>在一定时间内，没有数据交互，即处于 idle 状态时，客服端或服务器端会发送一个数据给对方，即ping-pong，当某一端收到消息后，即证明tcp连接仍然存在。</p><h3 id="netty的通讯协议是什么样的" tabindex="-1"><a class="header-anchor" href="#netty的通讯协议是什么样的" aria-hidden="true">#</a> netty的通讯协议是什么样的</h3><p>TCP粘包的解决方案 1.固定消息长度，不够补0 2.在不是同一个数据包之间设置特殊字符 3.不定长报文，包首部包含数据的长度。</p>`,23),o=[c];function l(i,p){return e(),n("div",null,o)}const d=a(t,[["render",l],["__file","007.Netty知识点.html.vue"]]);export{d as default};
