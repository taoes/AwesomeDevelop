<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.67">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>燕归来兮的个人文档</title><meta name="description" content="这是我的第一个 VuePress 站点">
    <link rel="preload" href="/assets/style-187f7d64.css" as="style"><link rel="stylesheet" href="/assets/style-187f7d64.css">
    <link rel="modulepreload" href="/assets/app-d035ab8f.js"><link rel="modulepreload" href="/assets/003.JVM 面试笔记.html-a33c10d7.js"><link rel="modulepreload" href="/assets/003.JVM 面试笔记.html-bdbbcf3f.js"><link rel="prefetch" href="/assets/README.en.html-6b6a9504.js" as="script"><link rel="prefetch" href="/assets/index.html-4a88c52e.js" as="script"><link rel="prefetch" href="/assets/example.html-891a7e01.js" as="script"><link rel="prefetch" href="/assets/000.面试题总结.html-15c810bf.js" as="script"><link rel="prefetch" href="/assets/001.Spring知识点.html-d7a4aff0.js" as="script"><link rel="prefetch" href="/assets/002.JavaSE知识点.html-e78de8e3.js" as="script"><link rel="prefetch" href="/assets/004.MySQL知识点.html-1f45604c.js" as="script"><link rel="prefetch" href="/assets/005.Redis知识点.html-b267d6f4.js" as="script"><link rel="prefetch" href="/assets/006.Tomcat知识点.html-16865875.js" as="script"><link rel="prefetch" href="/assets/007.Netty知识点.html-db7103da.js" as="script"><link rel="prefetch" href="/assets/008.消息队列.html-6d6c20e5.js" as="script"><link rel="prefetch" href="/assets/009.计算机网络.html-5e9e8514.js" as="script"><link rel="prefetch" href="/assets/010.常用算法.html-840f63a8.js" as="script"><link rel="prefetch" href="/assets/011.解决问题.html-5217aa7e.js" as="script"><link rel="prefetch" href="/assets/012.分布式知识点.html-09f224bd.js" as="script"><link rel="prefetch" href="/assets/013.微服务源码.html-f5ef7c74.js" as="script"><link rel="prefetch" href="/assets/014.Java并发编程.html-641c46a5.js" as="script"><link rel="prefetch" href="/assets/015.排序算法.html-4df091f3.js" as="script"><link rel="prefetch" href="/assets/016.数据结构.html-babc778b.js" as="script"><link rel="prefetch" href="/assets/index.html-79188762.js" as="script"><link rel="prefetch" href="/assets/000.Redis概述.html-3f3fa5f4.js" as="script"><link rel="prefetch" href="/assets/001.Redis的数据结构与对象.html-1693d2e7.js" as="script"><link rel="prefetch" href="/assets/index.html-8692e59c.js" as="script"><link rel="prefetch" href="/assets/index.html-685506ae.js" as="script"><link rel="prefetch" href="/assets/对NPE的防范与思考.html-de1e0922.js" as="script"><link rel="prefetch" href="/assets/index.html-2da14dbd.js" as="script"><link rel="prefetch" href="/assets/领域模型初步认识.html-af120107.js" as="script"><link rel="prefetch" href="/assets/index.html-4f8db8fe.js" as="script"><link rel="prefetch" href="/assets/index.html-5fea925e.js" as="script"><link rel="prefetch" href="/assets/index.html-c7c06e91.js" as="script"><link rel="prefetch" href="/assets/index.html-4aa3ee93.js" as="script"><link rel="prefetch" href="/assets/MyBatis_项目搭建以及配置项.html-035b19d8.js" as="script"><link rel="prefetch" href="/assets/MyBatis概念.html-a3b2d0f0.js" as="script"><link rel="prefetch" href="/assets/MyBatis的前世今生.html-edd8dc73.js" as="script"><link rel="prefetch" href="/assets/index.html-df35b0a8.js" as="script"><link rel="prefetch" href="/assets/001.Spring深入学习笔记概述.html-3733a7fc.js" as="script"><link rel="prefetch" href="/assets/002.Spring_Bean的创建方式.html-c9cd8cff.js" as="script"><link rel="prefetch" href="/assets/003.Spring_Bean的属性注入.html-5282c249.js" as="script"><link rel="prefetch" href="/assets/004.Spring_常用注解示例.html-3eefd4ba.js" as="script"><link rel="prefetch" href="/assets/005.Spring_Bean的循环依赖以及其解决方式.html-9782e378.js" as="script"><link rel="prefetch" href="/assets/006.BeanPostProcessor_的底层原理以及应用.html-d00f9bac.js" as="script"><link rel="prefetch" href="/assets/007.SpringAOP_从EnableAspectJAutoProxy说起.html-716bfaae.js" as="script"><link rel="prefetch" href="/assets/index.html-dbdc7ad3.js" as="script"><link rel="prefetch" href="/assets/ApplicationContextInitializer.html-1d5a7853.js" as="script"><link rel="prefetch" href="/assets/ApplicationListener.html-7a6b1841.js" as="script"><link rel="prefetch" href="/assets/JAR文件格式以及JDWP调试.html-34da7b6d.js" as="script"><link rel="prefetch" href="/assets/JarLauncher_源码分析.html-fbc92581.js" as="script"><link rel="prefetch" href="/assets/index.html-bc50857f.js" as="script"><link rel="prefetch" href="/assets/SpringApplicationEvent_使用以及实现原理.html-77e54afd.js" as="script"><link rel="prefetch" href="/assets/SpringBoot_注解源码分析.html-c9c272bf.js" as="script"><link rel="prefetch" href="/assets/SpringBoot_相关模块详解.html-30457575.js" as="script"><link rel="prefetch" href="/assets/SpringBoot的日志配置.html-7a6fb070.js" as="script"><link rel="prefetch" href="/assets/SpringFactoriesLoader.html-09b8abbb.js" as="script"><link rel="prefetch" href="/assets/SprintApplication_源码分析.html-60ed5552.js" as="script"><link rel="prefetch" href="/assets/index.html-b62ffce0.js" as="script"><link rel="prefetch" href="/assets/Ribbon_客户端负载均衡.html-3a1f6b9b.js" as="script"><link rel="prefetch" href="/assets/Zuul_网关路由.html-38550869.js" as="script"><link rel="prefetch" href="/assets/微服务熔断机制与Hystrix原理.html-8bd34ee3.js" as="script"><link rel="prefetch" href="/assets/服务注册与发现.html-4a80d0a3.js" as="script"><link rel="prefetch" href="/assets/概述.html-27746dbf.js" as="script"><link rel="prefetch" href="/assets/ArrayList底层源码分析.html-8ab056a1.js" as="script"><link rel="prefetch" href="/assets/HashMap底层源码分析.html-dea79cdd.js" as="script"><link rel="prefetch" href="/assets/HashSet底层源码分析.html-14dcbdc8.js" as="script"><link rel="prefetch" href="/assets/LinkedList底层源码分析.html-6ba1ecf4.js" as="script"><link rel="prefetch" href="/assets/Java网络通信IO模型(JavaBIO_NIO_AIO).html-96e01264.js" as="script"><link rel="prefetch" href="/assets/深入了解NIO核心类_ByteBuffer.html-3ec4fc84.js" as="script"><link rel="prefetch" href="/assets/Google工具库_Guava.html-b8c04e0b.js" as="script"><link rel="prefetch" href="/assets/Lambda增强_VAVR.html-74e1b7be.js" as="script"><link rel="prefetch" href="/assets/JDK8_Lambda.html-a55e093c.js" as="script"><link rel="prefetch" href="/assets/JDK8_Optional.html-56e14874.js" as="script"><link rel="prefetch" href="/assets/反射之方法句柄.html-230a69da.js" as="script"><link rel="prefetch" href="/assets/404.html-f9875e7b.js" as="script"><link rel="prefetch" href="/assets/README.en.html-8942e480.js" as="script"><link rel="prefetch" href="/assets/index.html-1de5f303.js" as="script"><link rel="prefetch" href="/assets/example.html-ed1ea6d6.js" as="script"><link rel="prefetch" href="/assets/000.面试题总结.html-eef71399.js" as="script"><link rel="prefetch" href="/assets/001.Spring知识点.html-8d3dec5f.js" as="script"><link rel="prefetch" href="/assets/002.JavaSE知识点.html-1e17b112.js" as="script"><link rel="prefetch" href="/assets/004.MySQL知识点.html-efb0a1cd.js" as="script"><link rel="prefetch" href="/assets/005.Redis知识点.html-ca027112.js" as="script"><link rel="prefetch" href="/assets/006.Tomcat知识点.html-4981a357.js" as="script"><link rel="prefetch" href="/assets/007.Netty知识点.html-0ecf38b6.js" as="script"><link rel="prefetch" href="/assets/008.消息队列.html-d266d2ed.js" as="script"><link rel="prefetch" href="/assets/009.计算机网络.html-3783714a.js" as="script"><link rel="prefetch" href="/assets/010.常用算法.html-a8d8037d.js" as="script"><link rel="prefetch" href="/assets/011.解决问题.html-b33cc5b6.js" as="script"><link rel="prefetch" href="/assets/012.分布式知识点.html-c148edc4.js" as="script"><link rel="prefetch" href="/assets/013.微服务源码.html-f2e03e26.js" as="script"><link rel="prefetch" href="/assets/014.Java并发编程.html-d99ae081.js" as="script"><link rel="prefetch" href="/assets/015.排序算法.html-cb23a514.js" as="script"><link rel="prefetch" href="/assets/016.数据结构.html-cc609677.js" as="script"><link rel="prefetch" href="/assets/index.html-b72c0744.js" as="script"><link rel="prefetch" href="/assets/000.Redis概述.html-9066954a.js" as="script"><link rel="prefetch" href="/assets/001.Redis的数据结构与对象.html-4406c732.js" as="script"><link rel="prefetch" href="/assets/index.html-f40bcc64.js" as="script"><link rel="prefetch" href="/assets/index.html-06bec4ee.js" as="script"><link rel="prefetch" href="/assets/对NPE的防范与思考.html-ebaa89a1.js" as="script"><link rel="prefetch" href="/assets/index.html-b8b12eae.js" as="script"><link rel="prefetch" href="/assets/领域模型初步认识.html-0da23ca7.js" as="script"><link rel="prefetch" href="/assets/index.html-9c0dddd7.js" as="script"><link rel="prefetch" href="/assets/index.html-ea1c4426.js" as="script"><link rel="prefetch" href="/assets/index.html-96abe4a3.js" as="script"><link rel="prefetch" href="/assets/index.html-8ef5896a.js" as="script"><link rel="prefetch" href="/assets/MyBatis_项目搭建以及配置项.html-72c7c37c.js" as="script"><link rel="prefetch" href="/assets/MyBatis概念.html-a09f597f.js" as="script"><link rel="prefetch" href="/assets/MyBatis的前世今生.html-2eb54efa.js" as="script"><link rel="prefetch" href="/assets/index.html-b750e764.js" as="script"><link rel="prefetch" href="/assets/001.Spring深入学习笔记概述.html-94c4f845.js" as="script"><link rel="prefetch" href="/assets/002.Spring_Bean的创建方式.html-446bba22.js" as="script"><link rel="prefetch" href="/assets/003.Spring_Bean的属性注入.html-a4619446.js" as="script"><link rel="prefetch" href="/assets/004.Spring_常用注解示例.html-c7fbb2a2.js" as="script"><link rel="prefetch" href="/assets/005.Spring_Bean的循环依赖以及其解决方式.html-32f7c94a.js" as="script"><link rel="prefetch" href="/assets/006.BeanPostProcessor_的底层原理以及应用.html-df1f2318.js" as="script"><link rel="prefetch" href="/assets/007.SpringAOP_从EnableAspectJAutoProxy说起.html-f30a7877.js" as="script"><link rel="prefetch" href="/assets/index.html-2ae2ce1f.js" as="script"><link rel="prefetch" href="/assets/ApplicationContextInitializer.html-9c43daf9.js" as="script"><link rel="prefetch" href="/assets/ApplicationListener.html-956bd052.js" as="script"><link rel="prefetch" href="/assets/JAR文件格式以及JDWP调试.html-87a5c0ee.js" as="script"><link rel="prefetch" href="/assets/JarLauncher_源码分析.html-afc3ec44.js" as="script"><link rel="prefetch" href="/assets/index.html-452b4fe8.js" as="script"><link rel="prefetch" href="/assets/SpringApplicationEvent_使用以及实现原理.html-b350ee1a.js" as="script"><link rel="prefetch" href="/assets/SpringBoot_注解源码分析.html-a4180d7e.js" as="script"><link rel="prefetch" href="/assets/SpringBoot_相关模块详解.html-a1586d49.js" as="script"><link rel="prefetch" href="/assets/SpringBoot的日志配置.html-9816e1c9.js" as="script"><link rel="prefetch" href="/assets/SpringFactoriesLoader.html-4e0ced02.js" as="script"><link rel="prefetch" href="/assets/SprintApplication_源码分析.html-7fb7f6b4.js" as="script"><link rel="prefetch" href="/assets/index.html-d0230fdb.js" as="script"><link rel="prefetch" href="/assets/Ribbon_客户端负载均衡.html-afdb4f31.js" as="script"><link rel="prefetch" href="/assets/Zuul_网关路由.html-4f37d513.js" as="script"><link rel="prefetch" href="/assets/微服务熔断机制与Hystrix原理.html-97f82dcc.js" as="script"><link rel="prefetch" href="/assets/服务注册与发现.html-89a04e2b.js" as="script"><link rel="prefetch" href="/assets/概述.html-c800f488.js" as="script"><link rel="prefetch" href="/assets/ArrayList底层源码分析.html-94cbe166.js" as="script"><link rel="prefetch" href="/assets/HashMap底层源码分析.html-19a0e898.js" as="script"><link rel="prefetch" href="/assets/HashSet底层源码分析.html-6050841b.js" as="script"><link rel="prefetch" href="/assets/LinkedList底层源码分析.html-486c3e30.js" as="script"><link rel="prefetch" href="/assets/Java网络通信IO模型(JavaBIO_NIO_AIO).html-b28439cd.js" as="script"><link rel="prefetch" href="/assets/深入了解NIO核心类_ByteBuffer.html-1bde3f33.js" as="script"><link rel="prefetch" href="/assets/Google工具库_Guava.html-ac7c1ee4.js" as="script"><link rel="prefetch" href="/assets/Lambda增强_VAVR.html-2ea2af87.js" as="script"><link rel="prefetch" href="/assets/JDK8_Lambda.html-0961b412.js" as="script"><link rel="prefetch" href="/assets/JDK8_Optional.html-d4900163.js" as="script"><link rel="prefetch" href="/assets/反射之方法句柄.html-9b829b04.js" as="script"><link rel="prefetch" href="/assets/404.html-415c46ad.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">燕归来兮的个人文档</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://www.zhoutao123.com" rel="noopener noreferrer" target="_blank" aria-label="📖 我的网站"><!--[--><!--]--> 📖 我的网站 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/taoes" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://gitee.com/taoes_admin" rel="noopener noreferrer" target="_blank" aria-label="GitEE"><!--[--><!--]--> GitEE <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://www.zhoutao123.com" rel="noopener noreferrer" target="_blank" aria-label="📖 我的网站"><!--[--><!--]--> 📖 我的网站 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://github.com/taoes" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://gitee.com/taoes_admin" rel="noopener noreferrer" target="_blank" aria-label="GitEE"><!--[--><!--]--> GitEE <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#what-is-jvm" class="router-link-active router-link-exact-active sidebar-item" aria-label="What is JVM ?"><!--[--><!--]--> What is JVM ? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_1-jvm内存区域" class="router-link-active router-link-exact-active sidebar-item" aria-label="1. JVM内存区域"><!--[--><!--]--> 1. JVM内存区域 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_1-1-对象创建过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.1 对象创建过程"><!--[--><!--]--> 1.1 对象创建过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_1-2-对象的内存布局以及访问" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.2 对象的内存布局以及访问"><!--[--><!--]--> 1.2 对象的内存布局以及访问 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_1-3-java-内存的溢出" class="router-link-active router-link-exact-active sidebar-item" aria-label="1.3 JAVA 内存的溢出"><!--[--><!--]--> 1.3 JAVA 内存的溢出 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_2、垃圾回收器" class="router-link-active router-link-exact-active sidebar-item" aria-label="2、垃圾回收器"><!--[--><!--]--> 2、垃圾回收器 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_2-1-引用的方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.1 引用的方式"><!--[--><!--]--> 2.1 引用的方式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_2-2-对象拯救" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.2 对象拯救"><!--[--><!--]--> 2.2 对象拯救 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_2-3-方法区的回收" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.3 方法区的回收"><!--[--><!--]--> 2.3 方法区的回收 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_2-4-垃圾回收器算法" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.4 垃圾回收器算法"><!--[--><!--]--> 2.4 垃圾回收器算法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_2-5-垃圾回收器" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.5 垃圾回收器"><!--[--><!--]--> 2.5 垃圾回收器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_2-6-内存分配策略" class="router-link-active router-link-exact-active sidebar-item" aria-label="2.6 内存分配策略"><!--[--><!--]--> 2.6 内存分配策略 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#gc-触发时机" class="router-link-active router-link-exact-active sidebar-item" aria-label="GC 触发时机"><!--[--><!--]--> GC 触发时机 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_3、虚拟机监控方式" class="router-link-active router-link-exact-active sidebar-item" aria-label="3、虚拟机监控方式"><!--[--><!--]--> 3、虚拟机监控方式 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_4、类文件结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="4、类文件结构"><!--[--><!--]--> 4、类文件结构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_5、类加载机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="5、类加载机制"><!--[--><!--]--> 5、类加载机制 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_5-1-类加载机制的时候" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.1 类加载机制的时候"><!--[--><!--]--> 5.1 类加载机制的时候 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_5-2-类加载的过程" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.2 类加载的过程"><!--[--><!--]--> 5.2 类加载的过程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#_5-3-类加载器" class="router-link-active router-link-exact-active sidebar-item" aria-label="5.3 类加载器"><!--[--><!--]--> 5.3 类加载器 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#类执行机制" class="router-link-active router-link-exact-active sidebar-item" aria-label="类执行机制"><!--[--><!--]--> 类执行机制 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#动态分派与静态分派" class="router-link-active router-link-exact-active sidebar-item" aria-label="动态分派与静态分派"><!--[--><!--]--> 动态分派与静态分派 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/interview/003.JVM%20%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0.html#常用参数" class="router-link-active router-link-exact-active sidebar-item" aria-label="常用参数"><!--[--><!--]--> 常用参数 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><p>[toc]</p><h2 id="what-is-jvm" tabindex="-1"><a class="header-anchor" href="#what-is-jvm" aria-hidden="true">#</a> What is JVM ?</h2><blockquote><p>JVM=ClassLoader + Java Exec + JMM</p></blockquote><h2 id="_1-jvm内存区域" tabindex="-1"><a class="header-anchor" href="#_1-jvm内存区域" aria-hidden="true">#</a> 1. JVM内存区域</h2><p>JVM的内存划分为几个区域：</p><ol><li><p>线程共享的区域:</p><p>Java堆内存：new 关键字创建的区域</p><p>方法区: Class、常量、静态变量</p><p>直接内存: ByteBuf</p></li><li><p>线程独占的内存区域</p><ul><li>虚拟机栈: 虚拟机栈帧(局部变量表/操作数栈/动态连接/返回地址)</li><li>本地方法栈:</li><li>程序计数器: PC</li></ul></li></ol><h3 id="_1-1-对象创建过程" tabindex="-1"><a class="header-anchor" href="#_1-1-对象创建过程" aria-hidden="true">#</a> 1.1 对象创建过程</h3><ol><li>检查类是否已加载, 否则去加载Class(了解类的加载过程)</li><li>为对象申请内存[指针碰撞、空闲列表]，线程不安全，通过CAS实现线程安全的问题 或者 TLAB (本地线程分配缓存), TLAB 会预先在线程中分配缓存，TLAB 用完的时候才会触发重新申请内存，才需要同步锁定，可以通过 -XX:+UserTLAB 参数设定</li><li>初始化零值(不包含对象头), 初始化对象头 (hashCode、元数据信息、GC年龄，锁信息)</li><li>执行init方法，即构造方法, 赋值给引用</li></ol><h3 id="_1-2-对象的内存布局以及访问" tabindex="-1"><a class="header-anchor" href="#_1-2-对象的内存布局以及访问" aria-hidden="true">#</a> 1.2 对象的内存布局以及访问</h3><ol><li>对象头、实例数据、对其填充(可选)</li><li>对象的访问通过两种方式: <ul><li>本地变量表-&gt; 句柄池 -&gt; 实例池和方法区的类(对应移动，不改变本地变量的引用)</li><li>本地变量表-&gt; 实例池 -&gt; 方法区的类</li></ul></li></ol><h3 id="_1-3-java-内存的溢出" tabindex="-1"><a class="header-anchor" href="#_1-3-java-内存的溢出" aria-hidden="true">#</a> 1.3 JAVA 内存的溢出</h3><ul><li>OutOfMemoryError： 堆内存溢出</li><li>StackOverflowError: 栈溢出</li><li>OutOfMemoryError: PermGen space 永久代移除</li></ul><h2 id="_2、垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_2、垃圾回收器" aria-hidden="true">#</a> 2、垃圾回收器</h2><p>GC的三大问题： 哪些内存需要回收？ 什么时候回收？如何回收？</p><p>使用引用计数法和可达性分析可以判断变量是否需要回收！引用计数器无法解决循环引用的问题，一般使用可达性分析判断是否需要回收。但是引用计数器实现简单，一些VM也在使用这种方式判断对象是否是需要回收</p><p>可以作为 GC Roots的有: <strong>方法区中的静态变量、常量、JNI引用的对象、以及本地变量表中引用的对象</strong></p><h3 id="_2-1-引用的方式" tabindex="-1"><a class="header-anchor" href="#_2-1-引用的方式" aria-hidden="true">#</a> 2.1 引用的方式</h3><ul><li>强引用: 只要强引用还在，GC就不会回收该对象</li><li>软引用: 没有有效的内存的时候则会回收，一般作为本地内存</li><li>弱引用: 下次GC的时候就会回收，使用场景是ThreadLocal的KEY</li><li>虚引用: 无法获取引用的值，一般用来实现堆外内存的管理,比如 NIO 堆外内存的回收</li></ul><h3 id="_2-2-对象拯救" tabindex="-1"><a class="header-anchor" href="#_2-2-对象拯救" aria-hidden="true">#</a> 2.2 对象拯救</h3><p>当对象准备回收的时候，Finalize() 方法会被调用，此变量会放置于F-Queue队列中，一个低优先级的线程会执行此队列对象的finalize方法，但是可以在finalize方法中重新的进行强引用，可以拯救内存。但是finalize 方法只会执行一次，第二回收的之后直接回收。</p><p><em>如果 finalize 方法中执行了死循环等方法，很有可能导致 F-Queue 队列中的其他执行卡死，造成整个内存回收机制崩溃</em></p><h3 id="_2-3-方法区的回收" tabindex="-1"><a class="header-anchor" href="#_2-3-方法区的回收" aria-hidden="true">#</a> 2.3 方法区的回收</h3><p>方法区的回收主要涉及静态变量、常量以及Class对象的回收</p><p>判断一个Class常量是否是废弃常量很简单</p><ul><li>该类的所有实例都被回收</li><li>加载该类的ClassLoader被回收</li><li>该类对应的Class没有被引用</li></ul><h3 id="_2-4-垃圾回收器算法" tabindex="-1"><a class="header-anchor" href="#_2-4-垃圾回收器算法" aria-hidden="true">#</a> 2.4 垃圾回收器算法</h3><ul><li>标记-清除: 需要经历标记 &amp; 清除过程，效率不高，容易产生不连续内存碎片</li><li>复制: 将内存一分为二,其中一块内存用完时，将其中的存活的对象复制到另外一块，然后将其清空。这种方式适合频繁回收的情况，同时也会浪费50%的内存空间</li><li>标记-整理: 回收后，将存在的对象向一端移动，然后清理掉边界之外的内存。适合回收不频繁的内存区域，适合老年代</li><li>分代收集：将内存划分为新生代和老年代，新生代采用复制算法，老年代采用标记-整理算法</li></ul><h3 id="_2-5-垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_2-5-垃圾回收器" aria-hidden="true">#</a> 2.5 垃圾回收器</h3><p>这里仅仅说明 HotSpot支持的垃圾回收器</p><h4 id="_2-5-1-新生代垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_2-5-1-新生代垃圾回收器" aria-hidden="true">#</a> 2.5.1 新生代垃圾回收器</h4><ul><li>Serial: 单线程，复制算法，需要 STW</li><li>ParNew: Serial: 回收器的多线程版本</li><li>Parallel Scavenge: 多线程并行垃圾搜集器,复制算法，关注于吞吐量，而非停顿时间，JDK8 默认</li></ul><h4 id="_2-5-2-老年代垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_2-5-2-老年代垃圾回收器" aria-hidden="true">#</a> 2.5.2 老年代垃圾回收器</h4><p>CMS: （Concurrent Mark-Sweep）并发标记清除垃圾回收器，关注于停顿时间</p><ul><li>Serial Old: 单线程版本, 采用标记-整理算法</li><li>Parallel Old: 多线程并行垃圾回收器，JDK8 默认</li></ul><h4 id="_2-5-4-cms-详解" tabindex="-1"><a class="header-anchor" href="#_2-5-4-cms-详解" aria-hidden="true">#</a> 2.5.4 CMS 详解</h4><ol><li>初始标记: 需要STW,快速标记下能被GC Root关联的对象</li><li>并发标记: 整理变动</li><li>重新标记: 需要STW,补充标记初始标记期间导致变动的记录(同用户线程一起执行)</li><li>并发清除:</li></ol><hr><ol><li>低延迟的收集器：几乎没有长时间的停顿，应用程序只在Minor gc以及后台线程扫描老年代的时候发生极其短暂的停顿</li><li>更高的CPU使用：必须有足够的CPU资源用于运行后台的垃圾收集线程</li><li>CMS收集器对老年代收集的时候，不再进行任何压缩和整理的工作，意味着老年代随着应用的运行会变得<strong>碎片化</strong></li><li>碎片过多会影响大对象的分配，虽然老年代还有很大的剩余空间，但是没有连续的空间来分配大对象，这时候就会触发<em>Full GC</em></li><li>无法处理浮动垃圾，只能等待下一次清理</li></ol><h4 id="_2-5-4-g1-垃圾回收器" tabindex="-1"><a class="header-anchor" href="#_2-5-4-g1-垃圾回收器" aria-hidden="true">#</a> 2.5.4 G1 垃圾回收器</h4><p>G1(Garbage First)垃圾收集器是当今垃圾回收技术最前沿的成果之一。早在JDK7就已加入JVM的收集器大家庭中，成为HotSpot重点发展的垃圾回收技术。同优秀的CMS垃圾回收器一样，G1也是关注最小时延的垃圾回收器，也同样适合大尺寸堆内存的垃圾收集，官方也推荐使用G1来代替选择CMS。</p><ol><li><strong>G1收集器的最大特点</strong></li></ol><ul><li>G1最大的特点是引入分区的思路，弱化了分代的概念。</li><li>合理利用垃圾收集各个周期的资源，解决了其他收集器甚至CMS的众多缺陷。</li></ul><p><strong>2. G1相比较CMS的改进</strong></p><ul><li>算法： G1基于标记-整理算法, 不会产生空间碎片，分配大对象时不会无法得到连续的空间而提前触发一次FULL GC。</li><li>停顿时间可控： G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象。</li><li>并行与并发：G1能更充分的利用CPU，多核环境下的硬件优势来缩短stop the world的停顿时间。</li></ul><p><strong>3. CMS和G1的区别</strong></p><ul><li>CMS中，堆被分为PermGen，YoungGen，OldGen；而YoungGen又分了两个 survivor 区域。但在G1中，堆被平均分成几个区域(region)，在每个区域中，虽然也保留了新老代的概念，但是收集器是以整个区域为单位收集的。</li><li>G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（stop the world）的时候做。</li><li>G1会在Young GC中使用、而CMS只能在O区使用。</li></ul><p><strong>4. G1收集器的应用场景</strong> G1垃圾收集算法主要应用在多CPU大内存的服务中，在满足高吞吐量的同时，尽可能的满足垃圾回收时的暂停时间。</p><p>就目前而言、CMS还是默认首选的GC策略、可能在以下场景下G1更适合：</p><ul><li>服务端多核CPU、JVM内存占用较大的应用（至少大于4G）</li><li>应用在运行过程中会产生大量内存碎片、需要经常压缩空间</li><li>想要更可控、可预期的GC停顿周期，防止高并发下应用雪崩现象</li></ul><h3 id="_2-6-内存分配策略" tabindex="-1"><a class="header-anchor" href="#_2-6-内存分配策略" aria-hidden="true">#</a> 2.6 内存分配策略</h3><ol><li>对象优先在Eden区域</li><li>大对象直接进入老年代</li><li>长期存活对象进入老年代</li><li>空间分配担保： 在发生MinorGC之前，VM会检查下老年代的最大连续空间是否大于新生代对象总大小，如果大于则确保Minor是安全的，否则判断是否允许担保失败，是的话则判断老年代连续空间是否大于历次MinorGC存活对象的平均值，是的话则冒险执行MinorGC，否则则执行FullGC</li></ol><h3 id="gc-触发时机" tabindex="-1"><a class="header-anchor" href="#gc-触发时机" aria-hidden="true">#</a> GC 触发时机</h3><p>MinorGC 值得是年轻代的GC，Major 指的是老年代的GC，而FullGC 针对的是整个堆内存空间的GC</p><ul><li><p>MinorGC</p><ol><li>新生代 Eden 内存空间不足</li></ol></li><li><p>FullGC</p><ol><li>调用System.gc() 的时候</li><li>老年代空间不足的时候触发，回收后仍然内存不足的时候触发OOM</li><li>方法区内存不足(针对JDK8一下版本，此时方法区还未移动到元空间区域)</li><li>通过 MinorGC 后进入老年代的平均大小大于老年代的可用内存</li><li>Eden + Survivor#0 向 Survivor#2 复制的时候，Survivor空间不足，且老年代空间也不足的时候</li></ol></li></ul><blockquote><ol><li>在发生MinorGC之前，VM会检查下老年代的最大连续空间是否大于新生代对象总大小</li><li>如果大于则确保Minor是安全的，如果小于新生代的内存大小，则判断是否允许担保失败</li><li>是的话则判断老年代连续空间是否大于历次MinorGC存活对象的平均值，是的话则冒险执行MinorGC，否则则执行FullGC</li></ol></blockquote><h2 id="_3、虚拟机监控方式" tabindex="-1"><a class="header-anchor" href="#_3、虚拟机监控方式" aria-hidden="true">#</a> 3、虚拟机监控方式</h2><ol><li>JPS 查询本地JVM的进程PID</li><li>Jstat 查询JVM的运行状态信息: 内存，GC，JIT，类加载等 <ul><li>-class 查询类的情况</li><li>-gc | -gcutil | -gcnew | -gcold 查询GC情况</li></ul></li><li>Jinfo 查询VM的参数信息(JDK8 不可用)</li><li>Jmap 生成堆 Dump 文件 （JDK8 不可用）</li><li>Jhat 分析堆转存文件</li><li>Jstack VM 堆栈跟踪工具，生成线程快照</li><li>JConsole Java监视与管理控制台</li><li>JVisualVM 多合一故障处理工具，支持插件</li><li>第三方监控工具 Jprofile/Arthas</li></ol><h2 id="_4、类文件结构" tabindex="-1"><a class="header-anchor" href="#_4、类文件结构" aria-hidden="true">#</a> 4、类文件结构</h2><p>Class文件的结构如下:</p><ol><li>(u4)魔数: OXCAFEBABE</li><li>(u2)主版本号和(u2)次版本号</li><li>(u2)常量池常量个数 + 常量池信息</li><li>(u2) 访问标记</li><li>(u2)当前类标记 + (u2) 父类标记 + (u2 * n)接口类标记 + (u2 * n) 接口字面量</li><li>(u2) 字段数量 + 字段占用空间</li><li>(u2) 方法数量 + 方法占用空间</li><li>(u2) 属性数量 + 属性占用空间 (Code,异常表等信息)</li></ol><h2 id="_5、类加载机制" tabindex="-1"><a class="header-anchor" href="#_5、类加载机制" aria-hidden="true">#</a> 5、类加载机制</h2><h3 id="_5-1-类加载机制的时候" tabindex="-1"><a class="header-anchor" href="#_5-1-类加载机制的时候" aria-hidden="true">#</a> 5.1 类加载机制的时候</h3><ol><li>遇到new,getStatic,putstatic,invokieStatic这四条指令的时候</li><li>使用反射机制对类进行反射调用的时候</li><li>当初始化一个类，但是父类没有被初始化的时候，会先初始化父类</li><li>虚拟机启动的时候，会加载Main方法所在的类</li><li>JDK1.7 以上使用方法句柄获取REF_getStatic,REF_putStatic以及REF_invokeStatic的时候，句柄所在的类没有初始化的时候会触发初始化</li></ol><blockquote><ol><li>调用子类的静态字段不会触发父类的初始化</li><li>初始化一个类的数组的时候，不会触发这个类的初始化，其创建指令为 newarray</li><li>调用某类的常亮的时候，不会触发初始化类，这是因为常量传播优化</li></ol></blockquote><h3 id="_5-2-类加载的过程" tabindex="-1"><a class="header-anchor" href="#_5-2-类加载的过程" aria-hidden="true">#</a> 5.2 类加载的过程</h3><ol><li>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</li><li>加载: 从存储介质中加载Class文件</li><li>验证: 验证class文件的魔数，版本号等信息</li><li>准备: 为类和静态变量分配内存，并初始化零值</li><li>解析: 将符号引用转换为直接引用</li><li>初始化: 搜集类的代码块生成 &lt;cinit&gt;方法，执行之</li><li>使用: 使用 new 字段触发对象的创建流程: 检查类是否加载,申请内存空间，执行&lt;init&gt;方法，赋值引用</li><li>卸载</li></ol><h3 id="_5-3-类加载器" tabindex="-1"><a class="header-anchor" href="#_5-3-类加载器" aria-hidden="true">#</a> 5.3 类加载器</h3><p>类加载在层次划分，OSGI，热部署以及代码加密方面上应用密切。比较两个类是否相等的前提是两个实例由同一个类加载器加载，这里的相等包括地址，equal,instance.</p><h4 id="_5-3-1-双亲委派机制" tabindex="-1"><a class="header-anchor" href="#_5-3-1-双亲委派机制" aria-hidden="true">#</a> 5.3.1 双亲委派机制</h4><ul><li>启动类加载器: 加载<code>&lt;JAVA_HOME&gt;/lib</code>目录下的文件，C++编写，无法直接引用</li><li>拓展类加载器: 加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录下的文件或者<code>java.ext.dirs</code> 指定的目录文件</li><li>应用类加载器: 加载ClassPath目录下的文件，一般是默认的类加载器</li><li>实现的目的是防止Java基本的类型体系被破坏</li></ul><h4 id="_5-3-1-自定义类加载器" tabindex="-1"><a class="header-anchor" href="#_5-3-1-自定义类加载器" aria-hidden="true">#</a> 5.3.1 自定义类加载器</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>


    <span class="token doc-comment comment">/**
     * 如果想要破坏双亲委派机制，那么久需要重写 loadClass 方法，其父类实现了双亲委派机制
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token doc-comment comment">/**
     * loadClass() 方法中使用的了模板方法的设计模式，当需要子类加载器加载类的时候，会执行findClass方法
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5-3-3-破坏双亲委派机制" tabindex="-1"><a class="header-anchor" href="#_5-3-3-破坏双亲委派机制" aria-hidden="true">#</a> 5.3.3 破坏双亲委派机制</h4><ul><li><p>兼容:JDK1.2 兼容JDK1.1的时候破坏了</p></li><li><p>SPI: 服务提供者接口</p></li><li><p>动态性: 代码热加载</p></li></ul><h4 id="_5-3-4-tomcat的类加载机制" tabindex="-1"><a class="header-anchor" href="#_5-3-4-tomcat的类加载机制" aria-hidden="true">#</a> 5.3.4 Tomcat的类加载机制</h4><div class="language-mermaid line-numbers-mode" data-ext="mermaid"><pre class="language-mermaid"><code><span class="token keyword">graph</span> TD
BootStarpClassLoader<span class="token arrow operator">--&gt;</span>ExtendsClassLoader
ExtendsClassLoader<span class="token arrow operator">--&gt;</span>ApplicationClassLoader
ApplicationClassLoader<span class="token arrow operator">--&gt;</span> CommonClassLoader
CommonClassLoader<span class="token arrow operator">--&gt;</span>CatalinaClassLoader
CommonClassLoader<span class="token arrow operator">--&gt;</span>SharedClassLoader
SharedClassLoader<span class="token arrow operator">--&gt;</span><span class="token label property">|破坏了双亲委派|</span>WebAppClassLoader
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Tomcat的类加载器说明</p><ul><li>CommonClassLoader: 以ApplicationClassLoader为父类加载器, 是位于Tomcat 应用服务器顶层的公用类加载器,默认是加载$CATALINE_HOME/lib 下的JAR包</li><li>CatalinaClassLoader: 以Common Class Loader 为父加载器.用于加载 Tomcat 应用服务器本身的</li><li>SharedClassLoader: 以Common 为父加载器,是所有web应用的父加载器.</li><li>WebAppClassLoader: 每个独立的Context(web应用)都使用独立的ClassLoader,其是破坏双亲委派机制的核心，只有其无法加载类的时候才会委托给父类加载器加载</li></ul><p>tomcat为什么要实现自己的类加载器模块?这是因为有几个问题Tomcat需要解决</p><ol><li>不同Web中依赖同一个JAR不同版本怎么办? 默认的类加载器只能加载一个类型</li></ol><blockquote><p>默认的类加载器根据全类名加载，不处理版本问题，因此需要实现自己的类加载器</p></blockquote><ol start="2"><li>Web容器也有自己的类库，不能和其他web容器和程序类搞混</li></ol><blockquote><p>这个上问题1类似</p></blockquote><ol start="3"><li><p>JSP 要支持热修改，怎么解决？</p><blockquote><p>对于JSP来说，其也是class文件，如果使用双亲委派机制，上层父类加载器认为其已经存在，不会再次加载，所以需要实现自己的类加载器</p></blockquote></li></ol><h2 id="类执行机制" tabindex="-1"><a class="header-anchor" href="#类执行机制" aria-hidden="true">#</a> 类执行机制</h2><p>栈帧： 适用于支撑虚拟机进行方法调用和方法执行的数据结构。他是虚拟机运行时候虚拟机栈的栈元素的数据结构。栈帧保存着局部变量表，操作数栈，动态连接以及返回地址，每个方法调用或者返回都对应着栈帧的入栈和出栈。</p><h3 id="动态分派与静态分派" tabindex="-1"><a class="header-anchor" href="#动态分派与静态分派" aria-hidden="true">#</a> 动态分派与静态分派</h3><p>JVM是一种静态多分派动态单分派的语言。</p><h2 id="常用参数" tabindex="-1"><a class="header-anchor" href="#常用参数" aria-hidden="true">#</a> 常用参数</h2><ol><li><p>-XX:+/-UseTLAB: 使用TLAB的方式</p></li><li><p>-XX:+HeapDumpOnOutOfMemoryError 当OOM时，dump堆内存</p></li><li><p>-Xms20m: 初始化堆内存大小</p></li><li><p>-Xmx20M: 最大堆内存大小</p></li><li><p>-Xss20M: 设置栈内存大小</p></li><li><p>-Xmn:256M 新生代大小</p></li><li><p>-Xss:1M 设置每个线程栈大小</p></li><li><p>-XX:NewSize=256M 设置新生代初始大小</p></li><li><p>-XX:PermSize &amp; -XX:MaxPermSize: 设置永久代大小</p></li><li><p>-XX:MaxDireactMemorySize 设置最大直接内存大小</p></li><li><p>-Xnoclassgc 控制是否回收class</p></li><li><p>-XX:-PrintGC 每次GC时打印相关信息</p></li><li><p>-XX:-PrintGCDetails 每次GC时打印详细信息</p></li><li><p>-XX:MaxTenuringThreshold=20 最大交互20次后，进入老年代</p></li><li><p>-Xss:20m 设置栈内存大小</p></li><li><p>-XX:NewRatio 设置老年代/新生代的比例</p></li><li><p>-XX:SurvivorRatio Survivor的比例</p></li></ol></div><!--[--><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/taoes/awesom_develop/-/edit/master/docs/interview/003.JVM 面试笔记.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页内容"><!--[--><!--]--> 编辑此页内容 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: taozhou.tao@alibaba-inc.com">Yan</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app-d035ab8f.js" defer></script>
  </body>
</html>
